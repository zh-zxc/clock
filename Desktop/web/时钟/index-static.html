<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Êó∂ÈíüÂ∫îÁî® - ‰∏≠ÂõΩÈ£éËÆæËÆ°">
    <title>Êó∂Èíü - ‰∏≠ÂõΩÈ£é</title>
    <style>
        /* ==================== ÂÖ®Â±ÄÂèòÈáè ==================== */
        :root {
            /* ‰∏≠ÂõΩÈ£éÈÖçËâ≤ - ‰º†ÁªüÂÖ∏ÈõÖ */
            --bg-primary: #f5f5dc;      /* Á±≥Ëâ≤ - ÂÆ£Á∫∏ */
            --bg-secondary: #e8e8d0;    /* ÊµÖÁ±≥Ëâ≤ */
            --bg-accent: #d4d4b8;       /* Ê∑±Á±≥Ëâ≤ */
            
            /* ‰º†ÁªüËâ≤ÂΩ© */
            --red-traditional: #c41e3a;    /* ‰∏≠ÂõΩÁ∫¢ */
            --gold-traditional: #d4af37;   /* ÈáëËâ≤ */
            --blue-traditional: #0066cc;   /* ÈùíËä±Ëìù */
            --green-traditional: #228b22;  /* Áø†Áªø */
            --black-traditional: #1a1a1a;  /* Â¢®Èªë */
            --white-traditional: #faf9f6;  /* Ë±°ÁâôÁôΩ */
            
            /* ÊñáÂ≠óÈ¢úËâ≤ */
            --text-primary: #2c2c2c;
            --text-secondary: #666666;
            --text-light: #999999;
            
            /* ËæπÊ°Ü */
            --border-color: rgba(0, 0, 0, 0.1);
            --border-traditional: rgba(139, 69, 19, 0.2); /* Ê£ïËâ≤ËæπÊ°Ü */
            
            /* Èò¥ÂΩ± */
            --shadow-soft: 0 2px 8px rgba(0, 0, 0, 0.08);
            --shadow-medium: 0 4px 16px rgba(0, 0, 0, 0.12);
            --shadow-strong: 0 8px 32px rgba(0, 0, 0, 0.15);
            
            /* ÂúÜËßí */
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-xl: 20px;
            --radius-traditional: 4px; /* ‰º†ÁªüÁõ¥Ëßí */
            
            /* Èó¥Ë∑ù */
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 12px;
            --space-lg: 16px;
            --space-xl: 24px;
            --space-2xl: 32px;
            --space-3xl: 48px;
            
            /* Âä®Áîª */
            --ease-smooth: cubic-bezier(0.4, 0, 0.2, 1);
            --ease-traditional: cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        /* Ê∑±Ëâ≤‰∏ªÈ¢ò - Â¢®Èüµ */
        .theme-dark {
            --bg-primary: #1a1a1a;
            --bg-secondary: #252525;
            --bg-accent: #303030;
            --text-primary: #e8e8e8;
            --text-secondary: #a0a0a0;
            --text-light: #666666;
            --border-color: rgba(255, 255, 255, 0.1);
            --border-traditional: rgba(212, 175, 55, 0.3);
        }

        /* ÈùíËä±‰∏ªÈ¢ò - Áì∑Èüµ */
        .theme-blue {
            --bg-primary: #e6f2ff;
            --bg-secondary: #d4e6ff;
            --bg-accent: #c2d9ff;
            --text-primary: #003366;
            --text-secondary: #005599;
            --text-light: #6699cc;
            --border-traditional: rgba(0, 102, 204, 0.3);
        }

        /* Á´πÈüµ‰∏ªÈ¢ò */
        .theme-bamboo {
            --bg-primary: #e8f5e9;
            --bg-secondary: #d4e8d4;
            --bg-accent: #c0dcc0;
            --text-primary: #1b5e20;
            --text-secondary: #2e7d32;
            --text-light: #66bb6a;
            --border-traditional: rgba(27, 94, 32, 0.3);
        }

        /* Ê¢ÖÈüµ‰∏ªÈ¢ò */
        .theme-plum {
            --bg-primary: #fff0f5;
            --bg-secondary: #ffe0e9;
            --bg-accent: #ffd0dc;
            --text-primary: #880e4f;
            --text-secondary: #c2185b;
            --text-light: #ec407a;
            --border-traditional: rgba(136, 14, 79, 0.3);
        }

        /* ==================== Âü∫Á°ÄÈáçÁΩÆ ==================== */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        /* ==================== ‰∏ªÂÆπÂô® ==================== */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            padding: var(--space-xl);
            line-height: 1.7;
            overflow-x: hidden;
            position: relative;
            transition: background 0.3s var(--ease-smooth), color 0.3s var(--ease-smooth);
        }

        /* ‰∏≠ÂõΩÈ£éËÉåÊôØË£ÖÈ•∞ - Âä®ÊÄÅ */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(212, 175, 55, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 90% 80%, rgba(196, 30, 58, 0.03) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
            transition: background-image 0.5s var(--ease-smooth);
        }

        /* Ê¢ÖËä±Ë£ÖÈ•∞ - Ê¢ÖÈüµ‰∏ªÈ¢ò */
        .theme-plum body::before {
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(212, 175, 55, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 90% 80%, rgba(196, 30, 58, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 20% 80%, rgba(255, 182, 193, 0.05) 0%, transparent 40%),
                radial-gradient(circle at 80% 20%, rgba(255, 105, 180, 0.05) 0%, transparent 40%),
                radial-gradient(circle at 15% 70%, rgba(255, 182, 193, 0.08) 0%, transparent 30%),
                radial-gradient(circle at 85% 30%, rgba(255, 105, 180, 0.08) 0%, transparent 30%);
        }

        /* Ê¢ÖËä±Ë£ÖÈ•∞ - Ê¢ÖÈüµ‰∏ªÈ¢òÈ¢ùÂ§ñË£ÖÈ•∞ */
        .theme-plum body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 25% 65%, rgba(255, 182, 193, 0.06) 0%, transparent 25%),
                radial-gradient(circle at 75% 35%, rgba(255, 105, 180, 0.06) 0%, transparent 25%),
                radial-gradient(circle at 40% 85%, rgba(255, 182, 193, 0.04) 0%, transparent 20%),
                radial-gradient(circle at 60% 15%, rgba(255, 105, 180, 0.04) 0%, transparent 20%);
            pointer-events: none;
            z-index: -1;
            opacity: 0.7;
        }

        /* Á´πÂ≠êË£ÖÈ•∞ - Á´πÈüµ‰∏ªÈ¢ò */
        .theme-bamboo body::before {
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(212, 175, 55, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 90% 80%, rgba(196, 30, 58, 0.03) 0%, transparent 50%),
                repeating-linear-gradient(
                    90deg,
                    transparent,
                    transparent 8px,
                    rgba(34, 139, 34, 0.03) 8px,
                    rgba(34, 139, 34, 0.03) 10px
                );
        }

        /* ÈùíËä±Ë£ÖÈ•∞ - ÈùíËä±‰∏ªÈ¢ò */
        .theme-blue body::before {
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(212, 175, 55, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 90% 80%, rgba(196, 30, 58, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(0, 102, 204, 0.05) 0%, transparent 60%);
        }

        /* ÂÆ£Á∫∏Ë£ÖÈ•∞ - ÂÆ£Á∫∏‰∏ªÈ¢ò */
        .theme-xuanzhi body::before {
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(212, 175, 55, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 90% 80%, rgba(196, 30, 58, 0.03) 0%, transparent 50%),
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 20px,
                    rgba(139, 69, 19, 0.02) 20px,
                    rgba(139, 69, 19, 0.02) 22px
                );
        }

        /* Â¢®ÈüµË£ÖÈ•∞ - Â¢®Èüµ‰∏ªÈ¢ò */
        .theme-dark body::before {
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(212, 175, 55, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 90% 80%, rgba(196, 30, 58, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 30% 70%, rgba(255, 255, 255, 0.02) 0%, transparent 50%);
        }

        /* ==================== ÂÆπÂô®Â∏ÉÂ±Ä ==================== */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        /* ==================== Â§¥ÈÉ®ÂØºËà™ ==================== */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-2xl);
            padding: var(--space-lg) var(--space-xl);
            background: var(--bg-secondary);
            border: 2px solid var(--border-traditional);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-soft);
            transition: all 0.3s var(--ease-smooth);
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, var(--gold-traditional), var(--red-traditional), var(--gold-traditional));
            background-size: 200% 100%;
            animation: shimmer 4s linear infinite;
        }

        .header:hover {
            box-shadow: var(--shadow-strong);
            transform: translateY(-2px);
        }

        .header-title {
            font-weight: 800;
            font-size: 1.6rem;
            letter-spacing: 3px;
            display: flex;
            align-items: center;
            gap: var(--space-md);
            color: var(--red-traditional);
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .header-title span:first-child {
            font-size: 2rem;
            animation: clockPulse 2s ease-in-out infinite;
        }

        .header-actions {
            display: flex;
            gap: var(--space-lg);
            align-items: center;
        }

        .header-actions .btn {
            padding: var(--space-md) var(--space-xl);
            font-size: 1rem;
            font-weight: 700;
            border-width: 2px;
        }

        /* ==================== ÊåâÈíÆÁ≥ªÁªü ==================== */
        .btn {
            padding: var(--space-sm) var(--space-lg);
            border: 1px solid var(--border-traditional);
            border-radius: var(--radius-traditional);
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            letter-spacing: 0.5px;
            transition: all 0.2s var(--ease-traditional);
            position: relative;
            overflow: hidden;
            display: inline-flex;
            align-items: center;
            gap: var(--space-xs);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(212, 175, 55, 0.2), transparent);
            transform: translateX(-100%);
            transition: transform 0.5s var(--ease-traditional);
        }

        .btn:hover::before {
            transform: translateX(100%);
        }

        .btn:hover {
            background: var(--gold-traditional);
            color: white;
            border-color: var(--gold-traditional);
            transform: translateY(-1px);
            box-shadow: var(--shadow-soft);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-primary {
            background: var(--red-traditional);
            color: white;
            border-color: var(--red-traditional);
        }

        .btn-primary:hover {
            background: #a0172d;
            border-color: #a0172d;
        }

        .btn-gold {
            background: var(--gold-traditional);
            color: white;
            border-color: var(--gold-traditional);
        }

        .btn-gold:hover {
            background: #c59a2f;
            border-color: #c59a2f;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* ==================== Êó∂ÈíüÂå∫Âüü ==================== */
        .clock-section {
            text-align: center;
            padding: var(--space-3xl) var(--space-2xl);
            background: var(--bg-secondary);
            border: 2px solid var(--border-traditional);
            border-radius: var(--radius-xl);
            margin-bottom: var(--space-2xl);
            box-shadow: var(--shadow-medium);
            position: relative;
            overflow: hidden;
            transition: all 0.3s var(--ease-smooth);
        }

        .clock-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 50% 50%, rgba(212, 175, 55, 0.05) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.5s var(--ease-smooth);
            pointer-events: none;
        }

        .clock-section:hover::before {
            opacity: 1;
        }

        .clock {
            font-size: 5rem;
            font-weight: 400;
            font-family: 'Courier New', 'Simsun', monospace;
            letter-spacing: 8px;
            margin-bottom: var(--space-lg);
            color: var(--black-traditional);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
            position: relative;
            display: inline-block;
            animation: clockPulse 2s ease-in-out infinite;
        }

        .theme-dark .clock {
            color: var(--gold-traditional);
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.3);
        }

        .date-display {
            font-size: 1.2rem;
            font-weight: 400;
            color: var(--text-secondary);
            letter-spacing: 2px;
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
        }

        /* ==================== ‰∏ªÁΩëÊ†ºÂ∏ÉÂ±Ä ==================== */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: var(--space-xl);
            margin-bottom: var(--space-2xl);
        }

        @media (max-width: 968px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        /* ==================== Âç°ÁâáÈÄöÁî®Ê†∑Âºè ==================== */
        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-traditional);
            border-radius: var(--radius-lg);
            padding: var(--space-xl);
            box-shadow: var(--shadow-soft);
            transition: all 0.3s var(--ease-smooth);
            position: relative;
            overflow: hidden;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-medium);
            border-color: var(--gold-traditional);
        }

        /* ==================== Êó•ÂéÜÊ†∑Âºè ==================== */
        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-lg);
        }

        .calendar-title {
            font-size: 1.2rem;
            font-weight: 600;
            letter-spacing: 1px;
            color: var(--red-traditional);
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
        }

        .calendar-nav {
            display: flex;
            gap: var(--space-sm);
        }

        .calendar-nav button {
            padding: var(--space-xs) var(--space-md);
            background: var(--bg-primary);
            border: 1px solid var(--border-traditional);
            border-radius: var(--radius-traditional);
            color: var(--text-primary);
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s var(--ease-traditional);
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
        }

        .calendar-nav button:hover {
            background: var(--gold-traditional);
            color: white;
            border-color: var(--gold-traditional);
            transform: scale(1.05);
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: var(--space-xs);
        }

        .day-header {
            text-align: center;
            font-weight: 600;
            font-size: 0.75rem;
            padding: var(--space-sm) 0;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.8;
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
        }

        .day {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-traditional);
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            background: var(--bg-primary);
            transition: all 0.2s var(--ease-traditional);
            border: 1px solid transparent;
            position: relative;
            overflow: hidden;
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
        }

        .day::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--gold-traditional);
            opacity: 0;
            transition: opacity 0.2s var(--ease-traditional);
            z-index: 0;
        }

        .day > * {
            position: relative;
            z-index: 1;
        }

        .day:hover {
            border-color: var(--gold-traditional);
            transform: scale(1.05);
        }

        .day:hover::before {
            opacity: 0.1;
        }

        .day.today {
            background: var(--red-traditional);
            color: white;
            font-weight: 600;
            box-shadow: 0 0 10px rgba(196, 30, 58, 0.3);
        }

        .day.selected {
            background: var(--gold-traditional);
            color: white;
            font-weight: 600;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
        }

        .day.has-data::after {
            content: '';
            position: absolute;
            bottom: 3px;
            right: 3px;
            width: 4px;
            height: 4px;
            background: var(--red-traditional);
            border-radius: 50%;
            opacity: 0.8;
        }

        .day.other-month {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* ==================== Êï∞ÊçÆÂå∫ÂüüÊ†∑Âºè ==================== */
        .section-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: var(--space-lg);
            color: var(--text-primary);
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
        }

        .input-group {
            margin-bottom: var(--space-lg);
        }

        .input-group label {
            display: block;
            margin-bottom: var(--space-xs);
            font-size: 0.85rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
        }

        .input-group input,
        .input-group textarea {
            width: 100%;
            padding: var(--space-md);
            background: var(--bg-primary);
            border: 1px solid var(--border-traditional);
            border-radius: var(--radius-traditional);
            color: var(--text-primary);
            font-family: inherit;
            font-size: 1rem;
            transition: all 0.2s var(--ease-traditional);
        }

        .input-group input:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: var(--gold-traditional);
            box-shadow: 0 0 0 2px rgba(212, 175, 55, 0.2);
            transform: translateY(-1px);
        }

        .expense-inputs {
            display: flex;
            gap: var(--space-md);
        }

        .expense-inputs input:first-child {
            flex: 0 0 30%;
        }

        .expense-inputs input:last-child {
            flex: 1;
        }

        .items-list {
            margin-top: var(--space-lg);
            max-height: 250px;
            overflow-y: auto;
            border-top: 1px solid var(--border-traditional);
            padding-top: var(--space-lg);
            scrollbar-width: thin;
            scrollbar-color: var(--gold-traditional) transparent;
        }

        .items-list::-webkit-scrollbar {
            width: 4px;
        }

        .items-list::-webkit-scrollbar-thumb {
            background: var(--gold-traditional);
            border-radius: 2px;
        }

        .item {
            background: var(--bg-primary);
            border-radius: var(--radius-traditional);
            padding: var(--space-md);
            margin-bottom: var(--space-md);
            border: 1px solid var(--border-traditional);
            transition: all 0.2s var(--ease-traditional);
            position: relative;
            overflow: hidden;
        }

        .item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 3px;
            height: 100%;
            background: var(--gold-traditional);
            opacity: 0;
            transition: opacity 0.2s var(--ease-traditional);
        }

        .item:hover {
            transform: translateX(4px);
            border-color: var(--gold-traditional);
            box-shadow: var(--shadow-soft);
        }

        .item:hover::before {
            opacity: 1;
        }

        .item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-xs);
        }

        .item-date {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--red-traditional);
            letter-spacing: 0.5px;
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
        }

        .item-delete {
            background: transparent;
            border: none;
            color: var(--red-traditional);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            font-weight: 700;
            transition: all 0.2s var(--ease-traditional);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .item-delete::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--red-traditional);
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.2s var(--ease-traditional);
            z-index: -1;
        }

        .item-delete:hover {
            color: white;
            transform: scale(1.1);
        }

        .item-delete:hover::before {
            opacity: 1;
        }

        .item-content {
            font-size: 0.95rem;
            line-height: 1.6;
            font-weight: 400;
            word-wrap: break-word;
            color: var(--text-secondary);
        }

        .expense-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .expense-amount {
            font-weight: 700;
            color: var(--red-traditional);
            font-size: 1.2rem;
            font-family: 'Courier New', monospace;
        }

        .stats-bar {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: var(--space-md);
            margin-top: var(--space-lg);
            padding: var(--space-lg);
            background: var(--bg-primary);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-traditional);
        }

        .stat-item {
            text-align: center;
            padding: var(--space-md);
            background: var(--bg-secondary);
            border-radius: var(--radius-traditional);
            transition: all 0.2s var(--ease-traditional);
            border: 1px solid var(--border-traditional);
        }

        .stat-item:hover {
            transform: translateY(-2px);
            border-color: var(--gold-traditional);
            box-shadow: var(--shadow-soft);
        }

        .stat-label {
            font-size: 0.7rem;
            opacity: 0.8;
            margin-bottom: var(--space-xs);
            font-weight: 600;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
        }

        .stat-value {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--red-traditional);
            font-family: 'Courier New', monospace;
        }

        /* ==================== Á©∫Áä∂ÊÄÅ ==================== */
        .empty-state {
            text-align: center;
            padding: var(--space-2xl) var(--space-xl);
            color: var(--text-light);
            background: var(--bg-primary);
            border-radius: var(--radius-md);
            border: 1px dashed var(--border-traditional);
            opacity: 0.7;
        }

        .empty-state-icon {
            font-size: 2.5rem;
            margin-bottom: var(--space-md);
            opacity: 0.5;
        }

        .empty-state-text {
            font-size: 0.95rem;
            font-weight: 500;
            letter-spacing: 0.5px;
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
        }

        /* ==================== Ê∏∏ÊàèÂå∫Âüü ==================== */
        .game-section {
            margin-bottom: var(--space-2xl);
        }

        .game-container {
            display: flex;
            flex-direction: column;
            gap: var(--space-lg);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--space-lg);
            flex-wrap: wrap;
        }

        .game-stats {
            display: flex;
            gap: var(--space-md);
            flex-wrap: wrap;
        }

        .game-stats .stat-item {
            min-width: 80px;
            padding: var(--space-md);
        }

        .game-controls {
            display: flex;
            gap: var(--space-md);
            flex-wrap: wrap;
        }

        .game-controls .btn {
            padding: var(--space-sm) var(--space-md);
            font-size: 0.85rem;
        }

        /* Ê∏∏ÊàèÂàáÊç¢ÊåâÈíÆ */
        .game-tabs {
            display: flex;
            gap: var(--space-md);
            margin-bottom: var(--space-lg);
            flex-wrap: wrap;
        }

        .game-tabs .btn {
            flex: 1;
            min-width: 120px;
            padding: var(--space-md);
            font-size: 0.9rem;
            font-weight: 600;
        }

        .game-tabs .btn.btn-primary {
            background: var(--red-traditional);
            border-color: var(--red-traditional);
            color: white;
        }

        .game-tabs .btn.btn-secondary {
            background: var(--bg-primary);
            border-color: var(--border-traditional);
        }

        .game-tabs .btn.active {
            transform: translateY(-2px);
            box-shadow: var(--shadow-soft);
            border-color: var(--gold-traditional);
            background: var(--gold-traditional);
            color: white;
        }

        /* Ê∏∏ÊàèÊ∂àÊÅØ */
        .game-message {
            text-align: center;
            padding: var(--space-lg);
            border-radius: var(--radius-md);
            font-weight: 600;
            font-size: 1rem;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s var(--ease-traditional);
            border: 1px solid var(--border-traditional);
            background: var(--bg-primary);
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
        }

        .game-message.success {
            background: rgba(34, 139, 34, 0.1);
            border-color: var(--green-traditional);
            color: var(--green-traditional);
        }

        .game-message.info {
            background: rgba(0, 102, 204, 0.1);
            border-color: var(--blue-traditional);
            color: var(--blue-traditional);
        }

        .game-message.warning {
            background: rgba(212, 175, 55, 0.1);
            border-color: var(--gold-traditional);
            color: var(--gold-traditional);
        }

        /* ==================== Ê∏∏ÊàèÊùøÈÄöÁî®Ê†∑Âºè ==================== */
        .game-board {
            display: grid;
            gap: 2px;
            max-width: 400px;
            margin: 0 auto;
            width: 100%;
            background: var(--bg-primary);
            border-radius: var(--radius-md);
            padding: var(--space-sm);
            border: 1px solid var(--border-traditional);
        }

        /* ==================== ËÆ∞ÂøÜÁøªÁâåÊ∏∏Êàè ==================== */
        .memory-board {
            grid-template-columns: repeat(4, 1fr);
        }

        .game-card {
            aspect-ratio: 1;
            background: var(--bg-secondary);
            border: 1px solid var(--border-traditional);
            border-radius: var(--radius-traditional);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            font-weight: 700;
            color: transparent;
            transition: all 0.2s var(--ease-traditional);
            user-select: none;
            position: relative;
            overflow: hidden;
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
        }

        .game-card:hover {
            transform: scale(1.05);
            border-color: var(--gold-traditional);
            box-shadow: 0 4px 12px rgba(212, 175, 55, 0.2);
        }

        .game-card.flipped {
            background: var(--gold-traditional);
            color: white;
            border-color: var(--gold-traditional);
            transform: scale(1.02);
        }

        .game-card.matched {
            background: var(--green-traditional);
            border-color: var(--green-traditional);
            cursor: default;
            opacity: 0.9;
        }

        .game-card.matched:hover {
            transform: none;
            box-shadow: none;
        }

        .game-card.wrong {
            background: var(--red-traditional);
            border-color: var(--red-traditional);
            animation: shake 0.4s var(--ease-traditional);
        }

        /* ==================== Ë¥™ÂêÉËõáÊ∏∏Êàè ==================== */
        .snake-board {
            grid-template-columns: repeat(15, 1fr);
            max-width: 450px;
        }

        .snake-cell {
            aspect-ratio: 1;
            background: var(--bg-secondary);
            border-radius: var(--radius-traditional);
            transition: all 0.1s var(--ease-traditional);
        }

        .snake-cell.snake {
            background: var(--green-traditional);
            border-radius: 2px;
        }

        .snake-cell.snake-head {
            background: var(--red-traditional);
            border-radius: 3px;
        }

        .snake-cell.food {
            background: var(--gold-traditional);
            border-radius: 50%;
            animation: pulse 1s var(--ease-traditional) infinite;
        }

        .snake-cell.wall {
            background: var(--black-traditional);
            border-radius: 2px;
        }

        /* ==================== Êé®ÁÆ±Â≠êÊ∏∏Êàè ==================== */
        .sokoban-board {
            grid-template-columns: repeat(8, 1fr);
            max-width: 400px;
        }

        .sokoban-cell {
            aspect-ratio: 1;
            background: var(--bg-secondary);
            border-radius: var(--radius-traditional);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: 700;
            transition: all 0.1s var(--ease-traditional);
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
        }

        .sokoban-cell.wall {
            background: var(--black-traditional);
            border-radius: var(--radius-traditional);
        }

        .sokoban-cell.floor {
            background: var(--bg-primary);
        }

        .sokoban-cell.target {
            background: var(--gold-traditional);
            border-radius: 50%;
            opacity: 0.6;
        }

        .sokoban-cell.box {
            background: var(--red-traditional);
            border-radius: var(--radius-traditional);
        }

        .sokoban-cell.box-on-target {
            background: var(--blue-traditional);
            border-radius: var(--radius-traditional);
        }

        .sokoban-cell.player {
            background: var(--gold-traditional);
            border-radius: 50%;
            animation: pulse 1s var(--ease-traditional) infinite;
        }

        /* ==================== ‰∏≠ÂõΩË±°Ê£ãÊ∏∏Êàè ==================== */
        .chess-board {
            grid-template-columns: repeat(9, 1fr);
            max-width: 450px;
        }

        .chess-cell {
            aspect-ratio: 1;
            background: var(--bg-primary);
            border: 1px solid var(--border-traditional);
            border-radius: var(--radius-traditional);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.1s var(--ease-traditional);
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
            user-select: none;
        }

        .chess-cell:hover {
            background: var(--bg-secondary);
            transform: scale(1.05);
            border-color: var(--gold-traditional);
        }

        .chess-cell.red-piece {
            color: var(--red-traditional);
        }

        .chess-cell.black-piece {
            color: var(--black-traditional);
        }

        .chess-cell.selected {
            background: var(--gold-traditional);
            color: white;
            border-color: var(--gold-traditional);
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }

        /* ==================== ‰∫îÂ≠êÊ£ãÊ∏∏Êàè ==================== */
        .gomoku-board {
            grid-template-columns: repeat(15, 1fr);
            max-width: 500px;
        }

        .gomoku-cell {
            aspect-ratio: 1;
            background: var(--bg-primary);
            border: 1px solid var(--border-traditional);
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.1s var(--ease-traditional);
            position: relative;
        }

        .gomoku-cell:hover {
            background: var(--bg-secondary);
            transform: scale(1.1);
            border-color: var(--gold-traditional);
        }

        .gomoku-cell.black-piece::after {
            content: '‚óè';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2rem;
            color: var(--black-traditional);
        }

        .gomoku-cell.white-piece::after {
            content: '‚óã';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2rem;
            color: var(--white-traditional);
        }

        /* ==================== ‰øÑÁΩóÊñØÊñπÂùóÊ∏∏Êàè ==================== */
        .tetris-board {
            grid-template-columns: repeat(10, 1fr);
            max-width: 350px;
        }

        .tetris-cell {
            aspect-ratio: 1;
            background: var(--bg-secondary);
            border-radius: 2px;
            transition: all 0.1s var(--ease-traditional);
        }

        /* ==================== Êâ´Èõ∑Ê∏∏Êàè ==================== */
        .minesweeper-board {
            grid-template-columns: repeat(10, 1fr);
            max-width: 400px;
        }

        .minesweeper-cell {
            aspect-ratio: 1;
            background: var(--bg-secondary);
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.1s var(--ease-traditional);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1rem;
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
        }

        .minesweeper-cell:hover {
            background: var(--bg-primary);
            transform: scale(1.05);
        }

        .minesweeper-cell.revealed {
            background: var(--bg-primary);
            cursor: default;
        }

        .minesweeper-cell.mine {
            background: var(--red-traditional);
            color: white;
        }

        .minesweeper-cell.flag {
            color: var(--red-traditional);
        }

        .minesweeper-cell.number-1 { color: #0000ff; }
        .minesweeper-cell.number-2 { color: #008000; }
        .minesweeper-cell.number-3 { color: #ff0000; }
        .minesweeper-cell.number-4 { color: #000080; }
        .minesweeper-cell.number-5 { color: #800000; }
        .minesweeper-cell.number-6 { color: #008080; }
        .minesweeper-cell.number-7 { color: #000000; }
        .minesweeper-cell.number-8 { color: #808080; }

        /* ==================== ‰∫ïÂ≠óÊ£ãÊ∏∏Êàè ==================== */
        .tictactoe-board {
            grid-template-columns: repeat(3, 1fr);
            max-width: 300px;
        }

        .tictactoe-cell {
            aspect-ratio: 1;
            background: var(--bg-secondary);
            border: 2px solid var(--border-traditional);
            border-radius: var(--radius-md);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            font-weight: 800;
            transition: all 0.2s var(--ease-traditional);
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
            user-select: none;
        }

        .tictactoe-cell:hover {
            background: var(--bg-primary);
            transform: scale(1.05);
            border-color: var(--gold-traditional);
        }

        .tictactoe-cell.player-x {
            color: var(--red-traditional);
        }

        .tictactoe-cell.player-o {
            color: var(--blue-traditional);
        }

        /* ==================== ËÉåÊôØÈÄâÊã©Âô® ==================== */
        .background-selector {
            display: flex;
            gap: var(--space-md);
            flex-wrap: wrap;
            margin-top: var(--space-lg);
            padding: var(--space-lg);
            background: var(--bg-primary);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-traditional);
        }

        .bg-option {
            width: 60px;
            height: 60px;
            border-radius: var(--radius-md);
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s var(--ease-traditional);
            position: relative;
            overflow: hidden;
        }

        .bg-option:hover {
            transform: scale(1.1);
            border-color: var(--gold-traditional);
        }

        .bg-option.active {
            border-color: var(--red-traditional);
            box-shadow: 0 0 10px rgba(196, 30, 58, 0.3);
        }

        .bg-option::after {
            content: attr(data-name);
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 0.6rem;
            text-align: center;
            padding: 2px;
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
        }

        /* ËÉåÊôØÈ¢ÑËßà */
        .bg-xuanzhi { background: linear-gradient(135deg, #f5f5dc, #e8e8d0); }
        .bg-moyun { background: linear-gradient(135deg, #1a1a1a, #252525); }
        .bg-qinghua { background: linear-gradient(135deg, #e6f2ff, #d4e6ff); }
        .bg-zhuyun { background: linear-gradient(135deg, #e8f5e9, #d4e8d4); }
        .bg-meiyun { background: linear-gradient(135deg, #fff0f5, #ffe0e9); }

        /* ==================== Ëá™ÂÆö‰πâËÉåÊôØÁºñËæëÂô® ==================== */
        .custom-bg-editor {
            margin-top: var(--space-lg);
            padding: var(--space-lg);
            background: var(--bg-primary);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-traditional);
        }

        .color-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: var(--space-md);
            margin-bottom: var(--space-lg);
        }

        .color-input-group {
            display: flex;
            flex-direction: column;
            gap: var(--space-xs);
        }

        .color-input-group label {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-secondary);
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
        }

        .color-input-wrapper {
            display: flex;
            gap: var(--space-xs);
            align-items: center;
        }

        .color-input-wrapper input[type="color"] {
            width: 40px;
            height: 30px;
            border: 1px solid var(--border-traditional);
            border-radius: var(--radius-traditional);
            cursor: pointer;
            background: transparent;
        }

        .color-input-wrapper input[type="text"] {
            flex: 1;
            padding: var(--space-xs) var(--space-sm);
            background: var(--bg-secondary);
            border: 1px solid var(--border-traditional);
            border-radius: var(--radius-traditional);
            color: var(--text-primary);
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
        }

        .bg-preview {
            width: 100%;
            height: 80px;
            border-radius: var(--radius-md);
            border: 2px solid var(--border-traditional);
            margin-bottom: var(--space-lg);
            position: relative;
            overflow: hidden;
            transition: all 0.3s var(--ease-smooth);
        }

        .bg-preview::before {
            content: 'È¢ÑËßà';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-primary);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
        }

        .bg-controls {
            display: flex;
            gap: var(--space-md);
            flex-wrap: wrap;
        }

        .bg-controls .btn {
            flex: 1;
            min-width: 120px;
        }

        /* ==================== ÂìçÂ∫îÂºèËÆæËÆ° ==================== */
        @media (max-width: 768px) {
            body {
                padding: var(--space-md);
            }

            .clock {
                font-size: 3.5rem;
                letter-spacing: 4px;
            }

            .date-display {
                font-size: 1rem;
            }

            .header {
                flex-direction: column;
                gap: var(--space-md);
                padding: var(--space-md);
            }

            .header-actions {
                width: 100%;
                justify-content: flex-end;
            }

            .stats-bar {
                grid-template-columns: 1fr;
            }

            .expense-inputs {
                flex-direction: column;
            }

            .expense-inputs input:first-child {
                flex: 1;
            }

            .clock-section {
                padding: var(--space-2xl) var(--space-lg);
            }

            .card {
                padding: var(--space-lg);
            }

            .game-board {
                max-width: 100%;
            }

            .bg-option {
                width: 50px;
                height: 50px;
            }

            .color-inputs {
                grid-template-columns: 1fr;
            }

            .bg-controls .btn {
                min-width: 100px;
            }
        }

        @media (max-width: 480px) {
            .clock {
                font-size: 2.5rem;
                letter-spacing: 2px;
            }

            .btn {
                padding: var(--space-xs) var(--space-md);
                font-size: 0.8rem;
            }

            .section-title {
                font-size: 1rem;
            }

            .stat-value {
                font-size: 1rem;
            }

            .game-tabs .btn {
                min-width: 100px;
                font-size: 0.8rem;
            }

            .snake-board {
                grid-template-columns: repeat(12, 1fr);
                max-width: 360px;
            }

            .sokoban-board {
                grid-template-columns: repeat(6, 1fr);
                max-width: 300px;
            }

            .game-card {
                font-size: 1.4rem;
            }

            .sokoban-cell {
                font-size: 1rem;
            }

            .bg-preview {
                height: 60px;
            }
        }

        /* ==================== Âä®ÁîªÁ≥ªÁªü ==================== */
        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        @keyframes clockPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-4px); }
            75% { transform: translateX(4px); }
        }

        /* ==================== È´òÂØπÊØîÂ∫¶Ê®°ÂºèÊîØÊåÅ ==================== */
        @media (prefers-contrast: high) {
            .btn,
            .day,
            .item,
            .game-card,
            .snake-cell,
            .sokoban-cell {
                border-width: 2px;
            }
        }

        /* ==================== ÂáèÂ∞ëÂä®ÁîªÊ®°ÂºèÊîØÊåÅ ==================== */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* ==================== ÊâìÂç∞Ê†∑Âºè ==================== */
        @media print {
            .header-actions,
            .calendar-nav,
            .item-delete,
            .input-group,
            .btn,
            .stats-bar,
            .game-section,
            .background-selector,
            .custom-bg-editor {
                display: none !important;
            }

            .clock-section {
                page-break-after: avoid;
                background: white !important;
                border: 1px solid #ccc !important;
            }

            .item {
                page-break-inside: avoid;
                background: white !important;
                border: 1px solid #ccc !important;
                color: black !important;
            }

            body {
                background: white !important;
                color: black !important;
            }
        }
    </style>
</head>
<body class="theme-xuanzhi">
    <div class="container">
        <!-- È°∂ÈÉ®ÂØºËà™ -->
        <header class="header" role="banner">
            <div class="header-title">
                <span aria-hidden="true">üïê</span>
                <span>Êó∂Èíü</span>
            </div>
            <div class="header-actions">
                <button class="btn" id="themeToggle" aria-label="ÂàáÊç¢‰∏ªÈ¢ò">
                    <span aria-hidden="true">üé®</span> ‰∏ªÈ¢ò
                </button>
            </div>
        </header>

        <!-- Êó∂ÈíüÂå∫Âüü -->
        <section class="clock-section" aria-label="ÂΩìÂâçÊó∂Èó¥">
            <div class="clock" id="clock" aria-live="polite">00:00:00</div>
            <div class="date-display" id="dateDisplay" aria-live="polite">Âä†ËΩΩ‰∏≠...</div>
        </section>

        <!-- ‰∏ªÂÜÖÂÆπ -->
        <main class="main-grid">
            <!-- Êó•ÂéÜ -->
            <section class="card calendar" aria-label="Êó•ÂéÜ">
                <div class="calendar-header">
                    <div class="calendar-title" id="calendarTitle" aria-live="polite">YYYYÂπ¥MMÊúà</div>
                    <div class="calendar-nav">
                        <button id="prevMonth" aria-label="‰∏ä‰∏™Êúà"><</button>
                        <button id="nextMonth" aria-label="‰∏ã‰∏™Êúà">></button>
                    </div>
                </div>
                <div class="calendar-grid" role="grid" aria-label="Êó•ÂéÜÁΩëÊ†º">
                    <div class="day-header" role="columnheader">Êó•</div>
                    <div class="day-header" role="columnheader">‰∏Ä</div>
                    <div class="day-header" role="columnheader">‰∫å</div>
                    <div class="day-header" role="columnheader">‰∏â</div>
                    <div class="day-header" role="columnheader">Âõõ</div>
                    <div class="day-header" role="columnheader">‰∫î</div>
                    <div class="day-header" role="columnheader">ÂÖ≠</div>
                </div>
                <div class="calendar-grid" id="calendarDays" role="grid" aria-label="Êó•ÊúüÈÄâÊã©"></div>
            </section>

            <!-- Êï∞ÊçÆ -->
            <section class="card data-section" aria-label="Êï∞ÊçÆÁÆ°ÁêÜ">
                <!-- ËÆ∞‰∫ã -->
                <div class="section-title">
                    <span aria-hidden="true">üìù</span>
                    <span>ËÆ∞‰∫ãÊú¨</span>
                </div>
                <div class="input-group">
                    <label for="noteInput">ËÆ∞‰∫ãÂÜÖÂÆπ</label>
                    <textarea 
                        id="noteInput" 
                        placeholder="Âú®Ê≠§ËæìÂÖ•ËÆ∞‰∫ãÂÜÖÂÆπ..."
                        aria-label="ËÆ∞‰∫ãÂÜÖÂÆπËæìÂÖ•Ê°Ü"
                        rows="3"
                    ></textarea>
                </div>
                <button class="btn btn-primary" id="saveNote" style="width: 100%;" aria-label="‰øùÂ≠òËÆ∞‰∫ã">
                    ‰øùÂ≠òËÆ∞‰∫ã
                </button>
                <div class="items-list" id="notesList" role="list" aria-label="ËÆ∞‰∫ãÂàóË°®"></div>

                <!-- Ê∂àË¥π -->
                <div class="section-title" style="margin-top: 25px;">
                    <span aria-hidden="true">üí∞</span>
                    <span>Ê∂àË¥πËÆ∞ÂΩï</span>
                </div>
                <div class="input-group">
                    <label for="expenseAmount">Ê∂àË¥π‰ø°ÊÅØ</label>
                    <div class="expense-inputs">
                        <input 
                            type="number" 
                            id="expenseAmount" 
                            placeholder="ÈáëÈ¢ù" 
                            step="0.01" 
                            min="0"
                            aria-label="Ê∂àË¥πÈáëÈ¢ù"
                        >
                        <input 
                            type="text" 
                            id="expenseDesc" 
                            placeholder="ÊèèËø∞"
                            aria-label="Ê∂àË¥πÊèèËø∞"
                        >
                    </div>
                </div>
                <button class="btn btn-primary" id="saveExpense" style="width: 100%;" aria-label="ËÆ∞ÂΩïÊ∂àË¥π">
                    ËÆ∞ÂΩïÊ∂àË¥π
                </button>
                <div class="items-list" id="expensesList" role="list" aria-label="Ê∂àË¥πÂàóË°®"></div>

                <!-- ÁªüËÆ° -->
                <div class="stats-bar" role="region" aria-label="Ê∂àË¥πÁªüËÆ°">
                    <div class="stat-item">
                        <div class="stat-label">Êú¨Êó•Ê∂àË¥π</div>
                        <div class="stat-value" id="todayExpense" aria-live="polite">¬•0.00</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Êú¨ÊúàÊ∂àË¥π</div>
                        <div class="stat-value" id="monthExpense" aria-live="polite">¬•0.00</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Âπ≥ÂùáÊØèÊó•</div>
                        <div class="stat-value" id="avgExpense" aria-live="polite">¬•0.00</div>
                    </div>
                </div>
            </section>
        </main>

        <!-- ËÉåÊôØÈÄâÊã©Âô® -->
        <section class="card" aria-label="ËÉåÊôØÈÄâÊã©">
            <div class="section-title">
                <span aria-hidden="true">üé®</span>
                <span>ËÉåÊôØÈÄâÊã©</span>
            </div>
            <div class="background-selector">
                <div class="bg-option bg-xuanzhi active" data-name="ÂÆ£Á∫∏" data-theme="xuanzhi" aria-label="ÈÄâÊã©ÂÆ£Á∫∏ËÉåÊôØ"></div>
                <div class="bg-option bg-moyun" data-name="Â¢®Èüµ" data-theme="dark" aria-label="ÈÄâÊã©Â¢®ÈüµËÉåÊôØ"></div>
                <div class="bg-option bg-qinghua" data-name="ÈùíËä±" data-theme="blue" aria-label="ÈÄâÊã©ÈùíËä±ËÉåÊôØ"></div>
                <div class="bg-option bg-zhuyun" data-name="Á´πÈüµ" data-theme="bamboo" aria-label="ÈÄâÊã©Á´πÈüµËÉåÊôØ"></div>
                <div class="bg-option bg-meiyun" data-name="Ê¢ÖÈüµ" data-theme="plum" aria-label="ÈÄâÊã©Ê¢ÖÈüµËÉåÊôØ"></div>
            </div>

            <!-- Ëá™ÂÆö‰πâËÉåÊôØÁºñËæëÂô® -->
            <div class="custom-bg-editor" id="customBgEditor" style="display: none;">
                <div class="section-title" style="margin-bottom: var(--space-md);">
                    <span aria-hidden="true">‚úèÔ∏è</span>
                    <span>Ëá™ÂÆö‰πâËÉåÊôØ</span>
                </div>
                
                <div class="bg-preview" id="bgPreview"></div>

                <div class="color-inputs">
                    <div class="color-input-group">
                        <label>‰∏ªËÉåÊôØËâ≤</label>
                        <div class="color-input-wrapper">
                            <input type="color" id="bgPrimaryColor" value="#f5f5dc">
                            <input type="text" id="bgPrimaryText" value="#f5f5dc" placeholder="#f5f5dc">
                        </div>
                    </div>
                    <div class="color-input-group">
                        <label>Ê¨°ËÉåÊôØËâ≤</label>
                        <div class="color-input-wrapper">
                            <input type="color" id="bgSecondaryColor" value="#e8e8d0">
                            <input type="text" id="bgSecondaryText" value="#e8e8d0" placeholder="#e8e8d0">
                        </div>
                    </div>
                    <div class="color-input-group">
                        <label>Âº∫Ë∞ÉËâ≤</label>
                        <div class="color-input-wrapper">
                            <input type="color" id="bgAccentColor" value="#d4d4b8">
                            <input type="text" id="bgAccentText" value="#d4d4b8" placeholder="#d4d4b8">
                        </div>
                    </div>
                    <div class="color-input-group">
                        <label>ÊñáÂ≠óËâ≤</label>
                        <div class="color-input-wrapper">
                            <input type="color" id="textPrimaryColor" value="#2c2c2c">
                            <input type="text" id="textPrimaryText" value="#2c2c2c" placeholder="#2c2c2c">
                        </div>
                    </div>
                    <div class="color-input-group">
                        <label>ËæπÊ°ÜËâ≤</label>
                        <div class="color-input-wrapper">
                            <input type="color" id="borderTraditionalColor" value="#8b4513">
                            <input type="text" id="borderTraditionalText" value="#8b4513" placeholder="#8b4513">
                        </div>
                    </div>
                    <div class="color-input-group">
                        <label>Ë£ÖÈ•∞Ëâ≤</label>
                        <div class="color-input-wrapper">
                            <input type="color" id="goldTraditionalColor" value="#d4af37">
                            <input type="text" id="goldTraditionalText" value="#d4af37" placeholder="#d4af37">
                        </div>
                    </div>
                </div>

                <!-- ÂõæÁâá‰∏ä‰º†Âå∫Âüü -->
                <div class="section-title" style="margin-top: var(--space-lg);">
                    <span aria-hidden="true">üñºÔ∏è</span>
                    <span>Ëá™ÂÆö‰πâÂõæÁâáËÉåÊôØ</span>
                </div>
                <div class="input-group">
                    <label for="bgImageUpload">‰∏ä‰º†ËÉåÊôØÂõæÁâá</label>
                    <input 
                        type="file" 
                        id="bgImageUpload" 
                        accept="image/*"
                        aria-label="‰∏ä‰º†ËÉåÊôØÂõæÁâá"
                        style="padding: var(--space-sm); background: var(--bg-secondary); border: 1px solid var(--border-traditional); border-radius: var(--radius-traditional); color: var(--text-primary); width: 100%;"
                    >
                    <small style="color: var(--text-secondary); font-size: 0.8rem; margin-top: var(--space-xs); display: block;">
                        ÊîØÊåÅ JPG, PNG, GIF, WebP Ê†ºÂºèÔºåÂª∫ËÆÆÂõæÁâáÂ∞∫ÂØ∏ 1920x1080 ‰ª•‰∏ä
                    </small>
                </div>

                <div class="input-group">
                    <label>ÂõæÁâáÊòæÁ§∫Ê®°Âºè</label>
                    <div style="display: flex; gap: var(--space-md); flex-wrap: wrap;">
                        <label style="display: flex; align-items: center; gap: var(--space-xs); cursor: pointer;">
                            <input type="radio" name="bgImageMode" value="cover" checked> Ë¶ÜÁõñ
                        </label>
                        <label style="display: flex; align-items: center; gap: var(--space-xs); cursor: pointer;">
                            <input type="radio" name="bgImageMode" value="contain"> ÂåÖÂê´
                        </label>
                        <label style="display: flex; align-items: center; gap: var(--space-xs); cursor: pointer;">
                            <input type="radio" name="bgImageMode" value="repeat"> Âπ≥Èì∫
                        </label>
                        <label style="display: flex; align-items: center; gap: var(--space-xs); cursor: pointer;">
                            <input type="radio" name="bgImageMode" value="center"> Â±Ö‰∏≠
                        </label>
                    </div>
                </div>

                <div class="input-group">
                    <label for="bgImageOpacity">ÂõæÁâáÈÄèÊòéÂ∫¶</label>
                    <input 
                        type="range" 
                        id="bgImageOpacity" 
                        min="0" 
                        max="100" 
                        value="50"
                        aria-label="ÂõæÁâáÈÄèÊòéÂ∫¶"
                        style="width: 100%;"
                    >
                    <small style="color: var(--text-secondary); font-size: 0.8rem;">
                        ÂΩìÂâçÂÄº: <span id="bgImageOpacityValue">50</span>%
                    </small>
                </div>

                <div class="input-group">
                    <label for="bgImageBlur">ÂõæÁâáÊ®°Á≥äÂ∫¶</label>
                    <input 
                        type="range" 
                        id="bgImageBlur" 
                        min="0" 
                        max="20" 
                        value="0"
                        aria-label="ÂõæÁâáÊ®°Á≥äÂ∫¶"
                        style="width: 100%;"
                    >
                    <small style="color: var(--text-secondary); font-size: 0.8rem;">
                        ÂΩìÂâçÂÄº: <span id="bgImageBlurValue">0</span>px
                    </small>
                </div>

                <div class="input-group">
                    <label for="bgImageBrightness">ÂõæÁâá‰∫ÆÂ∫¶</label>
                    <input 
                        type="range" 
                        id="bgImageBrightness" 
                        min="50" 
                        max="150" 
                        value="100"
                        aria-label="ÂõæÁâá‰∫ÆÂ∫¶"
                        style="width: 100%;"
                    >
                    <small style="color: var(--text-secondary); font-size: 0.8rem;">
                        ÂΩìÂâçÂÄº: <span id="bgImageBrightnessValue">100</span>%
                    </small>
                </div>

                <div class="bg-controls">
                    <button class="btn btn-primary" id="applyCustomBg" aria-label="Â∫îÁî®Ëá™ÂÆö‰πâËÉåÊôØ">
                        <span aria-hidden="true">‚úì</span> Â∫îÁî®
                    </button>
                    <button class="btn btn-gold" id="saveCustomBg" aria-label="‰øùÂ≠òËá™ÂÆö‰πâËÉåÊôØ">
                        <span aria-hidden="true">üíæ</span> ‰øùÂ≠ò
                    </button>
                    <button class="btn" id="resetCustomBg" aria-label="ÈáçÁΩÆËá™ÂÆö‰πâËÉåÊôØ">
                        <span aria-hidden="true">‚Ü∫</span> ÈáçÁΩÆ
                    </button>
                    <button class="btn" id="toggleCustomEditor" aria-label="Êî∂Ëµ∑ÁºñËæëÂô®">
                        <span aria-hidden="true">‚ñ≤</span> Êî∂Ëµ∑
                    </button>
                </div>
            </div>

            <button class="btn btn-gold" id="showCustomEditor" style="margin-top: var(--space-md); width: 100%;" aria-label="ÊâìÂºÄËá™ÂÆö‰πâËÉåÊôØÁºñËæëÂô®">
                <span aria-hidden="true">‚úèÔ∏è</span> Ëá™ÂÆö‰πâËÉåÊôØ
            </button>
        </section>

        <!-- Ê∏∏ÊàèÂå∫Âüü -->
        <section class="card game-section" aria-label="Â∞èÊ∏∏Êàè">
            <div class="section-title">
                <span aria-hidden="true">üéÆ</span>
                <span>Â∞èÊ∏∏Êàè</span>
            </div>
            
            <!-- Ê∏∏ÊàèÂàáÊç¢ÊåâÈíÆ -->
            <div class="game-tabs">
                <button class="btn btn-primary" id="tabMemory" aria-label="ÂàáÊç¢Âà∞ËÆ∞ÂøÜÁøªÁâåÊ∏∏Êàè">ËÆ∞ÂøÜÁøªÁâå</button>
                <button class="btn btn-secondary" id="tabSnake" aria-label="ÂàáÊç¢Âà∞Ë¥™ÂêÉËõáÊ∏∏Êàè">Ë¥™ÂêÉËõá</button>
                <button class="btn btn-secondary" id="tabSokoban" aria-label="ÂàáÊç¢Âà∞Êé®ÁÆ±Â≠êÊ∏∏Êàè">Êé®ÁÆ±Â≠ê</button>
                <button class="btn btn-secondary" id="tabChess" aria-label="ÂàáÊç¢Âà∞‰∏≠ÂõΩË±°Ê£ãÊ∏∏Êàè">‰∏≠ÂõΩË±°Ê£ã</button>
                <button class="btn btn-secondary" id="tabGomoku" aria-label="ÂàáÊç¢Âà∞‰∫îÂ≠êÊ£ãÊ∏∏Êàè">‰∫îÂ≠êÊ£ã</button>
                <button class="btn btn-secondary" id="tabTetris" aria-label="ÂàáÊç¢Âà∞‰øÑÁΩóÊñØÊñπÂùóÊ∏∏Êàè">‰øÑÁΩóÊñØÊñπÂùó</button>
                <button class="btn btn-secondary" id="tabMinesweeper" aria-label="ÂàáÊç¢Âà∞Êâ´Èõ∑Ê∏∏Êàè">Êâ´Èõ∑</button>
                <button class="btn btn-secondary" id="tabTicTacToe" aria-label="ÂàáÊç¢Âà∞‰∫ïÂ≠óÊ£ãÊ∏∏Êàè">‰∫ïÂ≠óÊ£ã</button>
            </div>

            <!-- ËÆ∞ÂøÜÁøªÁâåÊ∏∏Êàè -->
            <div id="memoryGameContainer" class="game-container">
                <div class="game-info">
                    <div class="game-stats">
                        <div class="stat-item">
                            <div class="stat-label">Ê≠•Êï∞</div>
                            <div class="stat-value" id="gameMoves">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Êó∂Èó¥</div>
                            <div class="stat-value" id="gameTime">0s</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">ÊúÄ‰Ω≥</div>
                            <div class="stat-value" id="gameBest">--</div>
                        </div>
                    </div>
                    <div class="game-controls">
                        <button class="btn btn-gold" id="startGame" aria-label="ÂºÄÂßãÊ∏∏Êàè">ÂºÄÂßãÊ∏∏Êàè</button>
                        <button class="btn btn-secondary" id="resetGame" aria-label="ÈáçÁΩÆÊ∏∏Êàè">ÈáçÁΩÆ</button>
                    </div>
                </div>
                <div class="game-board memory-board" id="gameBoard" role="grid" aria-label="Ê∏∏ÊàèÊùø"></div>
                <div class="game-message" id="gameMessage"></div>
            </div>

            <!-- Ë¥™ÂêÉËõáÊ∏∏Êàè -->
            <div id="snakeGameContainer" class="game-container" style="display: none;">
                <div class="game-info">
                    <div class="game-stats">
                        <div class="stat-item">
                            <div class="stat-label">ÂæóÂàÜ</div>
                            <div class="stat-value" id="snakeScore">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">ÈïøÂ∫¶</div>
                            <div class="stat-value" id="snakeLength">1</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">ÊúÄ‰Ω≥</div>
                            <div class="stat-value" id="snakeBest">--</div>
                        </div>
                    </div>
                    <div class="game-controls">
                        <button class="btn btn-gold" id="startSnake" aria-label="ÂºÄÂßãË¥™ÂêÉËõáÊ∏∏Êàè">ÂºÄÂßãÊ∏∏Êàè</button>
                        <button class="btn btn-secondary" id="resetSnake" aria-label="ÈáçÁΩÆË¥™ÂêÉËõáÊ∏∏Êàè">ÈáçÁΩÆ</button>
                    </div>
                </div>
                <div class="game-board snake-board" id="snakeBoard" role="grid" aria-label="Ë¥™ÂêÉËõáÊ∏∏ÊàèÊùø"></div>
                <div class="game-message" id="snakeMessage"></div>
                <div style="text-align: center; color: var(--text-secondary); font-size: 0.85rem; margin-top: 10px;">
                    ‰ΩøÁî®ÊñπÂêëÈîÆÊàñWASDÊéßÂà∂ËõáÁöÑÁßªÂä®
                </div>
            </div>

            <!-- Êé®ÁÆ±Â≠êÊ∏∏Êàè -->
            <div id="sokobanGameContainer" class="game-container" style="display: none;">
                <div class="game-info">
                    <div class="game-stats">
                        <div class="stat-item">
                            <div class="stat-label">ÂÖ≥Âç°</div>
                            <div class="stat-value" id="sokobanLevel">1</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Ê≠•Êï∞</div>
                            <div class="stat-value" id="sokobanMoves">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">ÊúÄ‰Ω≥</div>
                            <div class="stat-value" id="sokobanBest">--</div>
                        </div>
                    </div>
                    <div class="game-controls">
                        <button class="btn btn-gold" id="startSokoban" aria-label="ÂºÄÂßãÊé®ÁÆ±Â≠êÊ∏∏Êàè">ÂºÄÂßãÊ∏∏Êàè</button>
                        <button class="btn btn-secondary" id="resetSokoban" aria-label="ÈáçÁΩÆÊé®ÁÆ±Â≠êÊ∏∏Êàè">ÈáçÁΩÆ</button>
                        <button class="btn btn-secondary" id="nextLevel" aria-label="‰∏ã‰∏ÄÂÖ≥">‰∏ã‰∏ÄÂÖ≥</button>
                    </div>
                </div>
                <div class="game-board sokoban-board" id="sokobanBoard" role="grid" aria-label="Êé®ÁÆ±Â≠êÊ∏∏ÊàèÊùø"></div>
                <div class="game-message" id="sokobanMessage"></div>
                <div style="text-align: center; color: var(--text-secondary); font-size: 0.85rem; margin-top: 10px;">
                    ‰ΩøÁî®ÊñπÂêëÈîÆÁßªÂä®ÔºåÂ∞ÜÊâÄÊúâÁÆ±Â≠êÊé®Âà∞ÁõÆÊ†á‰ΩçÁΩÆ
                </div>
            </div>

            <!-- ‰∏≠ÂõΩË±°Ê£ãÊ∏∏Êàè -->
            <div id="chessGameContainer" class="game-container" style="display: none;">
                <div class="game-info">
                    <div class="game-stats">
                        <div class="stat-item">
                            <div class="stat-label">Ê≠•Êï∞</div>
                            <div class="stat-value" id="chessMoves">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">ÂΩìÂâç</div>
                            <div class="stat-value" id="chessPlayer">Á∫¢Êñπ</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">ÊúÄ‰Ω≥</div>
                            <div class="stat-value" id="chessBest">--</div>
                        </div>
                    </div>
                    <div class="game-controls">
                        <button class="btn btn-gold" id="startChess" aria-label="ÂºÄÂßã‰∏≠ÂõΩË±°Ê£ãÊ∏∏Êàè">ÂºÄÂßãÊ∏∏Êàè</button>
                        <button class="btn btn-secondary" id="resetChess" aria-label="ÈáçÁΩÆ‰∏≠ÂõΩË±°Ê£ãÊ∏∏Êàè">ÈáçÁΩÆ</button>
                    </div>
                </div>
                <div class="game-board chess-board" id="chessBoard" role="grid" aria-label="‰∏≠ÂõΩË±°Ê£ãÊ∏∏ÊàèÊùø"></div>
                <div class="game-message" id="chessMessage"></div>
                <div style="text-align: center; color: var(--text-secondary); font-size: 0.85rem; margin-top: 10px;">
                    ÁÇπÂáªÊ£ãÂ≠êÈÄâ‰∏≠ÔºåÂÜçÁÇπÂáªÁõÆÊ†á‰ΩçÁΩÆÁßªÂä®
                </div>
            </div>

            <!-- ‰∫îÂ≠êÊ£ãÊ∏∏Êàè -->
            <div id="gomokuGameContainer" class="game-container" style="display: none;">
                <div class="game-info">
                    <div class="game-stats">
                        <div class="stat-item">
                            <div class="stat-label">Ê≠•Êï∞</div>
                            <div class="stat-value" id="gomokuMoves">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">ÂΩìÂâç</div>
                            <div class="stat-value" id="gomokuPlayer">ÈªëÊñπ</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">ÊúÄ‰Ω≥</div>
                            <div class="stat-value" id="gomokuBest">--</div>
                        </div>
                    </div>
                    <div class="game-controls">
                        <button class="btn btn-gold" id="startGomoku" aria-label="ÂºÄÂßã‰∫îÂ≠êÊ£ãÊ∏∏Êàè">ÂºÄÂßãÊ∏∏Êàè</button>
                        <button class="btn btn-secondary" id="resetGomoku" aria-label="ÈáçÁΩÆ‰∫îÂ≠êÊ£ãÊ∏∏Êàè">ÈáçÁΩÆ</button>
                    </div>
                </div>
                <div class="game-board gomoku-board" id="gomokuBoard" role="grid" aria-label="‰∫îÂ≠êÊ£ãÊ∏∏ÊàèÊùø"></div>
                <div class="game-message" id="gomokuMessage"></div>
                <div style="text-align: center; color: var(--text-secondary); font-size: 0.85rem; margin-top: 10px;">
                    ÁÇπÂáªÊ£ãÁõòËêΩÂ≠êÔºå‰∫îÂ≠êËøûÁè†Ëé∑ËÉú
                </div>
            </div>

            <!-- ‰øÑÁΩóÊñØÊñπÂùóÊ∏∏Êàè -->
            <div id="tetrisGameContainer" class="game-container" style="display: none;">
                <div class="game-info">
                    <div class="game-stats">
                        <div class="stat-item">
                            <div class="stat-label">ÂæóÂàÜ</div>
                            <div class="stat-value" id="tetrisScore">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Á≠âÁ∫ß</div>
                            <div class="stat-value" id="tetrisLevel">1</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Ê∂àÈô§Ë°å</div>
                            <div class="stat-value" id="tetrisLines">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">ÊúÄ‰Ω≥</div>
                            <div class="stat-value" id="tetrisBest">--</div>
                        </div>
                    </div>
                    <div class="game-controls">
                        <button class="btn btn-gold" id="startTetris" aria-label="ÂºÄÂßã‰øÑÁΩóÊñØÊñπÂùóÊ∏∏Êàè">ÂºÄÂßãÊ∏∏Êàè</button>
                        <button class="btn btn-secondary" id="resetTetris" aria-label="ÈáçÁΩÆ‰øÑÁΩóÊñØÊñπÂùóÊ∏∏Êàè">ÈáçÁΩÆ</button>
                    </div>
                </div>
                <div class="game-board tetris-board" id="tetrisBoard" role="grid" aria-label="‰øÑÁΩóÊñØÊñπÂùóÊ∏∏ÊàèÊùø"></div>
                <div class="game-message" id="tetrisMessage"></div>
                <div style="text-align: center; color: var(--text-secondary); font-size: 0.85rem; margin-top: 10px;">
                    ‰ΩøÁî®ÊñπÂêëÈîÆÊéßÂà∂Ôºö‚Üê‚ÜíÁßªÂä®Ôºå‚ÜìÂä†ÈÄüÔºå‚ÜëÊóãËΩ¨ÔºåÁ©∫Ê†ºÂø´ÈÄü‰∏ãËêΩ
                </div>
            </div>

            <!-- Êâ´Èõ∑Ê∏∏Êàè -->
            <div id="minesweeperGameContainer" class="game-container" style="display: none;">
                <div class="game-info">
                    <div class="game-stats">
                        <div class="stat-item">
                            <div class="stat-label">Êó∂Èó¥</div>
                            <div class="stat-value" id="minesweeperTime">0s</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Ââ©‰ΩôÊ†áËÆ∞</div>
                            <div class="stat-value" id="minesweeperFlags">15</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">ÊúÄ‰Ω≥</div>
                            <div class="stat-value" id="minesweeperBest">--</div>
                        </div>
                    </div>
                    <div class="game-controls">
                        <button class="btn btn-gold" id="startMinesweeper" aria-label="ÂºÄÂßãÊâ´Èõ∑Ê∏∏Êàè">ÂºÄÂßãÊ∏∏Êàè</button>
                        <button class="btn btn-secondary" id="resetMinesweeper" aria-label="ÈáçÁΩÆÊâ´Èõ∑Ê∏∏Êàè">ÈáçÁΩÆ</button>
                    </div>
                </div>
                <div class="game-board minesweeper-board" id="minesweeperBoard" role="grid" aria-label="Êâ´Èõ∑Ê∏∏ÊàèÊùø"></div>
                <div class="game-message" id="minesweeperMessage"></div>
                <div style="text-align: center; color: var(--text-secondary); font-size: 0.85rem; margin-top: 10px;">
                    Â∑¶ÈîÆÁøªÂºÄÔºåÂè≥ÈîÆÊ†áËÆ∞ÔºåÊâæÂá∫ÊâÄÊúâÂú∞Èõ∑
                </div>
            </div>

            <!-- ‰∫ïÂ≠óÊ£ãÊ∏∏Êàè -->
            <div id="tictactoeGameContainer" class="game-container" style="display: none;">
                <div class="game-info">
                    <div class="game-stats">
                        <div class="stat-item">
                            <div class="stat-label">Ê≠•Êï∞</div>
                            <div class="stat-value" id="tictactoeMoves">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">ÂΩìÂâç</div>
                            <div class="stat-value" id="tictactoePlayer">X</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">ÊúÄ‰Ω≥</div>
                            <div class="stat-value" id="tictactoeBest">--</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Ê®°Âºè</div>
                            <div class="stat-value" id="tictactoeMode">ÁîµËÑë</div>
                        </div>
                    </div>
                    <div class="game-controls">
                        <button class="btn btn-gold" id="startTicTacToe" aria-label="ÂºÄÂßã‰∫ïÂ≠óÊ£ãÊ∏∏Êàè">ÂºÄÂßãÊ∏∏Êàè</button>
                        <button class="btn btn-secondary" id="resetTicTacToe" aria-label="ÈáçÁΩÆ‰∫ïÂ≠óÊ£ãÊ∏∏Êàè">ÈáçÁΩÆ</button>
                        <button class="btn btn-secondary" id="toggleTicTacToeMode" aria-label="ÂàáÊç¢Ê∏∏ÊàèÊ®°Âºè">ÂàáÊç¢Ê®°Âºè</button>
                    </div>
                </div>
                <div class="game-board tictactoe-board" id="tictactoeBoard" role="grid" aria-label="‰∫ïÂ≠óÊ£ãÊ∏∏ÊàèÊùø"></div>
                <div class="game-message" id="tictactoeMessage"></div>
                <div style="text-align: center; color: var(--text-secondary); font-size: 0.85rem; margin-top: 10px;">
                    ‰∏âÂ≠êËøûÁè†Ëé∑ËÉúÔºåXÂÖàËµ∞
                </div>
            </div>
        </section>

        <!-- ÊèêÁ§∫‰ø°ÊÅØ -->
        <footer style="text-align: center; padding: 20px; color: var(--text-light); font-size: 0.9rem;" role="contentinfo">
            üí° ‰∏≠ÂõΩÈ£éÊó∂ÈíüÂ∫îÁî® - ‰º†Áªü‰∏éÁé∞‰ª£ÁöÑÂÆåÁæéËûçÂêà
        </footer>
    </div>

    <script type="module">
        // ==================== ÈÖçÁΩÆÊ®°Âùó ====================
        const CONFIG = {
            STORAGE_KEYS: {
                NOTES: 'clock_notes',
                EXPENSES: 'clock_expenses',
                THEME: 'clock_theme',
                BACKGROUND: 'clock_background',
                CUSTOM_BG: 'clock_custom_background'
            },
            UPDATE_INTERVAL: 1000,
            DEBOUNCE_DELAY: 300,
            GAME_CONFIG: {
                MEMORY: {
                    icons: ['Á¶è', 'Á¶Ñ', 'ÂØø', 'Âñú', 'Ë¥¢', 'Âêâ', 'Á••', 'Áëû'],
                    boardSize: 4
                },
                SNAKE: {
                    boardSize: 15,
                    initialSpeed: 120,
                    speedIncrement: 8,
                    scorePerFood: 10,
                    speedUpThreshold: 50
                },
                SOKOBAN: {
                    boardSize: 8,
                    levels: [
                        {
                            map: [
                                [1,1,1,1,1,1,1,1],
                                [1,0,0,0,0,0,0,1],
                                [1,0,2,0,0,0,0,1],
                                [1,0,0,0,3,0,0,1],
                                [1,0,0,0,4,0,0,1],
                                [1,0,0,0,0,0,0,1],
                                [1,0,0,0,0,0,0,1],
                                [1,1,1,1,1,1,1,1]
                            ],
                            player: { x: 4, y: 4 },
                            boxes: [{ x: 2, y: 2 }],
                            targets: [{ x: 4, y: 3 }]
                        },
                        {
                            map: [
                                [1,1,1,1,1,1,1,1],
                                [1,1,1,0,0,1,1,1],
                                [1,1,1,2,0,1,1,1],
                                [1,0,0,3,0,0,0,1],
                                [1,0,0,2,4,0,0,1],
                                [1,0,0,3,0,0,0,1],
                                [1,1,1,1,1,1,1,1],
                                [1,1,1,1,1,1,1,1]
                            ],
                            player: { x: 4, y: 4 },
                            boxes: [{ x: 3, y: 2 }, { x: 3, y: 4 }],
                            targets: [{ x: 3, y: 3 }, { x: 3, y: 5 }]
                        },
                        {
                            map: [
                                [1,1,1,1,1,1,1,1],
                                [1,0,0,0,0,0,0,1],
                                [1,0,2,0,2,0,0,1],
                                [1,0,0,1,0,0,0,1],
                                [1,0,3,0,3,0,0,1],
                                [1,0,0,0,4,0,0,1],
                                [1,0,0,0,0,0,0,1],
                                [1,1,1,1,1,1,1,1]
                            ],
                            player: { x: 4, y: 5 },
                            boxes: [{ x: 2, y: 2 }, { x: 4, y: 2 }],
                            targets: [{ x: 2, y: 4 }, { x: 4, y: 4 }]
                        }
                    ]
                }
            }
        };

        // ==================== Â∑•ÂÖ∑ÂáΩÊï∞Ê®°Âùó ====================
        const Utils = {
            formatDate(date) {
                return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
            },

            generateId() {
                return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
            },

            formatCurrency(amount) {
                return `¬•${Number(amount).toFixed(2)}`;
            },

            getCurrentTimestamp() {
                return new Date().toISOString();
            },

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },

            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            },

            throttle(func, limit) {
                let inThrottle;
                return function(...args) {
                    if (!inThrottle) {
                        func.apply(this, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                };
            },

            // È¢úËâ≤Ê†ºÂºèÂåñ
            formatColor(color) {
                if (!color) return '#000000';
                if (color.startsWith('#')) return color;
                if (color.startsWith('rgb')) return color;
                return '#' + color.replace('#', '');
            },

            // È™åËØÅÈ¢úËâ≤
            isValidColor(color) {
                const s = new Option().style;
                s.color = color;
                return s.color !== '';
            }
        };

        // ==================== Êï∞ÊçÆÁÆ°ÁêÜÊ®°Âùó ====================
        const DataManager = {
            getData(key, defaultValue = {}) {
                try {
                    const data = localStorage.getItem(key);
                    return data ? JSON.parse(data) : defaultValue;
                } catch (error) {
                    console.warn(`Failed to read from localStorage: ${key}`, error);
                    return defaultValue;
                }
            },

            setData(key, data) {
                try {
                    localStorage.setItem(key, JSON.stringify(data));
                    return true;
                } catch (error) {
                    console.error(`Failed to write to localStorage: ${key}`, error);
                    if (error.name === 'QuotaExceededError') {
                        alert('Â≠òÂÇ®Á©∫Èó¥‰∏çË∂≥ÔºåËØ∑Ê∏ÖÁêÜ‰∏Ä‰∫õÊóßÊï∞ÊçÆ');
                    }
                    return false;
                }
            },

            addItem(key, dateKey, item) {
                const data = this.getData(key, {});
                if (!data[dateKey]) data[dateKey] = [];
                data[dateKey].push(item);
                data[dateKey].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                this.setData(key, data);
                return data;
            },

            deleteItem(key, dateKey, itemId) {
                const data = this.getData(key, {});
                if (data[dateKey]) {
                    data[dateKey] = data[dateKey].filter(item => item.id !== itemId);
                    if (data[dateKey].length === 0) delete data[dateKey];
                    this.setData(key, data);
                }
                return data;
            },

            getItems(key, dateKey) {
                const data = this.getData(key, {});
                return data[dateKey] || [];
            },

            getStats(selectedDate) {
                const expenses = this.getData(CONFIG.STORAGE_KEYS.EXPENSES, {});
                const dateKey = Utils.formatDate(selectedDate);
                const year = selectedDate.getFullYear();
                const month = selectedDate.getMonth();

                const todayExpense = expenses[dateKey]?.reduce((sum, e) => sum + e.amount, 0) || 0;

                let monthExpense = 0;
                let expenseDays = 0;
                
                Object.keys(expenses).forEach(key => {
                    const d = new Date(key);
                    if (d.getFullYear() === year && d.getMonth() === month) {
                        monthExpense += expenses[key].reduce((sum, e) => sum + e.amount, 0);
                        expenseDays++;
                    }
                });

                const avgExpense = expenseDays > 0 ? monthExpense / expenseDays : 0;

                return { todayExpense, monthExpense, avgExpense };
            },

            cleanupOldData() {
                const thirtyDaysAgo = new Date();
                thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

                const cleanupKey = (key) => {
                    const data = this.getData(key, {});
                    const cleanedData = {};

                    Object.keys(data).forEach(dateKey => {
                        const date = new Date(dateKey);
                        if (date >= thirtyDaysAgo) {
                            cleanedData[dateKey] = data[dateKey];
                        }
                    });

                    if (Object.keys(cleanedData).length < Object.keys(data).length) {
                        this.setData(key, cleanedData);
                        console.log(`Cleaned up old data for ${key}`);
                    }
                };

                cleanupKey(CONFIG.STORAGE_KEYS.NOTES);
                cleanupKey(CONFIG.STORAGE_KEYS.EXPENSES);
            }
        };

        // ==================== ËÉåÊôØÁÆ°ÁêÜÊ®°Âùó ====================
        class BackgroundManager {
            constructor() {
                this.currentTheme = 'xuanzhi';
                this.customColors = null;
                this.customImage = null;
                this.defaultColors = {
                    xuanzhi: {
                        bgPrimary: '#f5f5dc',
                        bgSecondary: '#e8e8d0',
                        bgAccent: '#d4d4b8',
                        textPrimary: '#2c2c2c',
                        borderTraditional: '#8b4513',
                        goldTraditional: '#d4af37'
                    },
                    dark: {
                        bgPrimary: '#1a1a1a',
                        bgSecondary: '#252525',
                        bgAccent: '#303030',
                        textPrimary: '#e8e8e8',
                        borderTraditional: '#d4af37',
                        goldTraditional: '#d4af37'
                    },
                    blue: {
                        bgPrimary: '#e6f2ff',
                        bgSecondary: '#d4e6ff',
                        bgAccent: '#c2d9ff',
                        textPrimary: '#003366',
                        borderTraditional: '#0066cc',
                        goldTraditional: '#d4af37'
                    },
                    bamboo: {
                        bgPrimary: '#e8f5e9',
                        bgSecondary: '#d4e8d4',
                        bgAccent: '#c0dcc0',
                        textPrimary: '#1b5e20',
                        borderTraditional: '#1b5e20',
                        goldTraditional: '#d4af37'
                    },
                    plum: {
                        bgPrimary: '#fff0f5',
                        bgSecondary: '#ffe0e9',
                        bgAccent: '#ffd0dc',
                        textPrimary: '#880e4f',
                        borderTraditional: '#880e4f',
                        goldTraditional: '#d4af37'
                    }
                };
            }

            loadSavedBackground() {
                try {
                    const savedTheme = localStorage.getItem(CONFIG.STORAGE_KEYS.BACKGROUND);
                    const savedCustom = localStorage.getItem(CONFIG.STORAGE_KEYS.CUSTOM_BG);
                    
                    if (savedTheme) {
                        this.currentTheme = savedTheme;
                    }
                    
                    if (savedCustom) {
                        const customData = JSON.parse(savedCustom);
                        if (customData.colors) {
                            this.customColors = customData.colors;
                        }
                        if (customData.image) {
                            this.customImage = customData.image;
                        }
                    }
                } catch (error) {
                    console.warn('Failed to load saved background:', error);
                }
            }

            applyTheme(theme) {
                this.currentTheme = theme;
                document.body.className = `theme-${theme}`;
                
                // Â¶ÇÊûúÊúâËá™ÂÆö‰πâÈ¢úËâ≤ÔºåÂ∫îÁî®ÂÆÉ‰ª¨
                if (this.customColors) {
                    this.applyCustomColors(this.customColors);
                }
                
                // Â¶ÇÊûúÊúâËá™ÂÆö‰πâÂõæÁâáÔºåÂ∫îÁî®ÂÆÉ‰ª¨
                if (this.customImage && this.customImage.data) {
                    this.applyCustomImage(this.customImage);
                }
                
                // Êõ¥Êñ∞UIÁä∂ÊÄÅ
                this.updateThemeUI();
            }

            applyCustomColors(colors) {
                this.customColors = colors;
                const root = document.documentElement;
                
                Object.keys(colors).forEach(key => {
                    const cssVar = `--${key.replace(/([A-Z])/g, '-$1').toLowerCase()}`;
                    root.style.setProperty(cssVar, colors[key]);
                });
            }

            applyCustomImage(imageSettings) {
                this.customImage = imageSettings;
                const root = document.documentElement;
                
                // ÂàõÂª∫ËÉåÊôØÂõæÁâáÊ†∑Âºè
                const imageStyle = `url(${imageSettings.data})`;
                const imageFilter = `blur(${imageSettings.blur}px) brightness(${imageSettings.brightness}%)`;
                const imageOpacity = imageSettings.opacity / 100;
                
                // Â∫îÁî®Âà∞bodyËÉåÊôØ
                const body = document.body;
                const colors = this.getCurrentColors();
                
                let backgroundStyle = `linear-gradient(135deg, ${colors.bgPrimary}, ${colors.bgSecondary})`;
                
                switch(imageSettings.mode) {
                    case 'cover':
                        backgroundStyle = `${backgroundStyle}, ${imageStyle}`;
                        body.style.backgroundSize = 'cover';
                        body.style.backgroundPosition = 'center';
                        body.style.backgroundRepeat = 'no-repeat';
                        break;
                    case 'contain':
                        backgroundStyle = `${backgroundStyle}, ${imageStyle}`;
                        body.style.backgroundSize = 'contain';
                        body.style.backgroundPosition = 'center';
                        body.style.backgroundRepeat = 'no-repeat';
                        break;
                    case 'repeat':
                        backgroundStyle = `${backgroundStyle}, ${imageStyle}`;
                        body.style.backgroundSize = 'auto';
                        body.style.backgroundPosition = 'center';
                        body.style.backgroundRepeat = 'repeat';
                        break;
                    case 'center':
                        backgroundStyle = `${backgroundStyle}, ${imageStyle}`;
                        body.style.backgroundSize = 'auto';
                        body.style.backgroundPosition = 'center';
                        body.style.backgroundRepeat = 'no-repeat';
                        break;
                }
                
                body.style.backgroundImage = backgroundStyle;
                body.style.filter = imageFilter;
                body.style.opacity = imageOpacity;
            }

            updateThemeUI() {
                document.querySelectorAll('.bg-option').forEach(option => {
                    option.classList.remove('active');
                    if (option.dataset.theme === this.currentTheme) {
                        option.classList.add('active');
                    }
                });
            }

            saveBackground() {
                try {
                    localStorage.setItem(CONFIG.STORAGE_KEYS.BACKGROUND, this.currentTheme);
                    if (this.customColors || this.customImage) {
                        const saveData = {
                            colors: this.customColors,
                            image: this.customImage
                        };
                        localStorage.setItem(CONFIG.STORAGE_KEYS.CUSTOM_BG, JSON.stringify(saveData));
                    }
                    return true;
                } catch (error) {
                    console.error('Failed to save background:', error);
                    return false;
                }
            }

            resetToDefault() {
                this.customColors = null;
                this.customImage = null;
                const root = document.documentElement;
                const body = document.body;
                
                // Ê∏ÖÈô§ÊâÄÊúâËá™ÂÆö‰πâCSSÂèòÈáè
                const style = getComputedStyle(root);
                const variables = [
                    '--bg-primary', '--bg-secondary', '--bg-accent',
                    '--text-primary', '--border-traditional', '--gold-traditional'
                ];
                
                variables.forEach(v => root.style.removeProperty(v));
                
                // Ê∏ÖÈô§ËÉåÊôØÂõæÁâáÊ†∑Âºè
                body.style.backgroundImage = '';
                body.style.backgroundSize = '';
                body.style.backgroundPosition = '';
                body.style.backgroundRepeat = '';
                body.style.filter = '';
                body.style.opacity = '';
                
                // ÈáçÊñ∞Â∫îÁî®‰∏ªÈ¢ò
                this.applyTheme(this.currentTheme);
            }

            getCurrentColors() {
                const style = getComputedStyle(document.documentElement);
                return {
                    bgPrimary: style.getPropertyValue('--bg-primary').trim(),
                    bgSecondary: style.getPropertyValue('--bg-secondary').trim(),
                    bgAccent: style.getPropertyValue('--bg-accent').trim(),
                    textPrimary: style.getPropertyValue('--text-primary').trim(),
                    borderTraditional: style.getPropertyValue('--border-traditional').trim(),
                    goldTraditional: style.getPropertyValue('--gold-traditional').trim()
                };
            }

            getDefaultColors(theme) {
                return this.defaultColors[theme] || this.defaultColors.xuanzhi;
            }
        }

        // ==================== Ê∏∏ÊàèÊ®°Âùó ====================
        
        // ËÆ∞ÂøÜÁøªÁâåÊ∏∏Êàè
        class MemoryGame {
            constructor() {
                this.cards = [];
                this.flippedCards = [];
                this.matchedPairs = 0;
                this.moves = 0;
                this.gameTime = 0;
                this.gameInterval = null;
                this.isGameActive = false;
                this.canFlip = true;
                this.storageKey = 'clock_game_best';
                this.icons = CONFIG.GAME_CONFIG.MEMORY.icons;
            }

            init() {
                this.loadBestScore();
                this.setupEventListeners();
                this.renderBoard();
                this.updateStats();
            }

            setupEventListeners() {
                const startBtn = document.getElementById('startGame');
                const resetBtn = document.getElementById('resetGame');

                if (startBtn) {
                    startBtn.addEventListener('click', () => this.startGame());
                }

                if (resetBtn) {
                    resetBtn.addEventListener('click', () => this.resetGame());
                }
            }

            startGame() {
                if (this.isGameActive) return;

                this.isGameActive = true;
                this.moves = 0;
                this.matchedPairs = 0;
                this.gameTime = 0;
                this.flippedCards = [];
                this.canFlip = true;

                const gameIcons = this.icons.slice(0, 8);
                this.cards = [...gameIcons, ...gameIcons]
                    .sort(() => Math.random() - 0.5)
                    .map((icon, index) => ({
                        id: index,
                        icon: icon,
                        isFlipped: false,
                        isMatched: false
                    }));

                this.renderBoard();
                this.updateStats();
                this.showMessage('Ê∏∏ÊàèÂºÄÂßãÔºÅÊâæÂá∫ÊâÄÊúâÂåπÈÖçÁöÑÂç°Áâá', 'info');
                this.startTimer();
            }

            resetGame() {
                this.stopTimer();
                this.isGameActive = false;
                this.moves = 0;
                this.gameTime = 0;
                this.matchedPairs = 0;
                this.flippedCards = [];
                this.canFlip = true;
                this.cards = [];

                this.renderBoard();
                this.updateStats();
                this.showMessage('ÁÇπÂáª"ÂºÄÂßãÊ∏∏Êàè"ÂºÄÂßãÊåëÊàòÔºÅ', 'info');
            }

            startTimer() {
                this.stopTimer();
                this.gameInterval = setInterval(() => {
                    this.gameTime++;
                    this.updateStats();
                }, 1000);
            }

            stopTimer() {
                if (this.gameInterval) {
                    clearInterval(this.gameInterval);
                    this.gameInterval = null;
                }
            }

            renderBoard() {
                const board = document.getElementById('gameBoard');
                if (!board) return;

                if (this.cards.length === 0) {
                    board.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 40px; color: var(--text-secondary);">ÁÇπÂáª"ÂºÄÂßãÊ∏∏Êàè"ÂºÄÂßãÊåëÊàò</div>';
                    return;
                }

                const fragment = document.createDocumentFragment();
                this.cards.forEach(card => {
                    const cardElement = document.createElement('div');
                    cardElement.className = 'game-card';
                    cardElement.setAttribute('role', 'gridcell');
                    cardElement.setAttribute('tabindex', '0');
                    cardElement.setAttribute('aria-label', 'Ê∏∏ÊàèÂç°Áâá');
                    
                    if (card.isFlipped || card.isMatched) {
                        cardElement.classList.add('flipped');
                        cardElement.textContent = card.icon;
                    } else {
                        cardElement.textContent = '';
                    }

                    if (card.isMatched) {
                        cardElement.classList.add('matched');
                    }

                    if (!card.isMatched && !card.isFlipped) {
                        cardElement.addEventListener('click', () => this.flipCard(card.id));
                        cardElement.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter' || e.key === ' ') {
                                e.preventDefault();
                                this.flipCard(card.id);
                            }
                        });
                    }

                    fragment.appendChild(cardElement);
                });

                board.innerHTML = '';
                board.appendChild(fragment);
            }

            flipCard(cardId) {
                if (!this.isGameActive || !this.canFlip) return;

                const card = this.cards.find(c => c.id === cardId);
                if (!card || card.isFlipped || card.isMatched) return;

                card.isFlipped = true;
                this.flippedCards.push(card);
                this.renderBoard();

                if (this.flippedCards.length === 2) {
                    this.moves++;
                    this.updateStats();
                    this.canFlip = false;
                    
                    setTimeout(() => this.checkMatch(), 400);
                }
            }

            checkMatch() {
                const [card1, card2] = this.flippedCards;

                if (card1.icon === card2.icon) {
                    card1.isMatched = true;
                    card2.isMatched = true;
                    this.matchedPairs++;
                    this.flippedCards = [];
                    this.canFlip = true;

                    this.renderBoard();
                    this.showMessage(`ÂåπÈÖçÊàêÂäüÔºÅ(${this.matchedPairs}/8)`, 'success');

                    if (this.matchedPairs === 8) {
                        this.gameWon();
                    }
                } else {
                    const cardElements = document.querySelectorAll('.game-card');
                    const indices = [card1.id, card2.id];
                    
                    indices.forEach(index => {
                        const element = cardElements[index];
                        if (element) {
                            element.classList.add('wrong');
                        }
                    });

                    setTimeout(() => {
                        card1.isFlipped = false;
                        card2.isFlipped = false;
                        this.flippedCards = [];
                        this.canFlip = true;
                        this.renderBoard();
                        this.showMessage('ÂÜçËØï‰∏ÄÊ¨°ÔºÅ', 'warning');
                    }, 600);
                }
            }

            gameWon() {
                this.stopTimer();
                this.isGameActive = false;

                const bestScore = this.getBestScore();
                const isNewRecord = !bestScore || this.moves < bestScore.moves || 
                                   (this.moves === bestScore.moves && this.gameTime < bestScore.time);

                if (isNewRecord) {
                    this.saveBestScore();
                    this.showMessage(`üéâ ÊÅ≠ÂñúÔºÅÊñ∞Á∫™ÂΩïÔºÅÊ≠•Êï∞Ôºö${this.moves}ÔºåÊó∂Èó¥Ôºö${this.gameTime}Áßí`, 'success');
                } else {
                    this.showMessage(`üéâ Ê∏∏ÊàèËÉúÂà©ÔºÅÊ≠•Êï∞Ôºö${this.moves}ÔºåÊó∂Èó¥Ôºö${this.gameTime}Áßí`, 'success');
                }

                this.updateStats();
            }

            updateStats() {
                const movesElement = document.getElementById('gameMoves');
                const timeElement = document.getElementById('gameTime');
                const bestElement = document.getElementById('gameBest');

                if (movesElement) movesElement.textContent = this.moves;
                if (timeElement) timeElement.textContent = `${this.gameTime}s`;

                const bestScore = this.getBestScore();
                if (bestElement && bestScore) {
                    bestElement.textContent = `${bestScore.moves}Ê≠•/${bestScore.time}Áßí`;
                } else if (bestElement) {
                    bestElement.textContent = '--';
                }
            }

            showMessage(text, type = 'info') {
                const messageElement = document.getElementById('gameMessage');
                if (!messageElement) return;

                messageElement.textContent = text;
                messageElement.className = `game-message ${type}`;
            }

            getBestScore() {
                try {
                    const data = localStorage.getItem(this.storageKey);
                    return data ? JSON.parse(data) : null;
                } catch (error) {
                    console.warn('Failed to load best score:', error);
                    return null;
                }
            }

            saveBestScore() {
                try {
                    const bestScore = {
                        moves: this.moves,
                        time: this.gameTime,
                        date: new Date().toISOString()
                    };
                    localStorage.setItem(this.storageKey, JSON.stringify(bestScore));
                } catch (error) {
                    console.warn('Failed to save best score:', error);
                }
            }

            loadBestScore() {
                // Â∑≤Âú®getBestScore‰∏≠Â§ÑÁêÜ
            }

            destroy() {
                this.stopTimer();
            }
        }

        class SnakeGame {
            constructor() {
                this.boardSize = CONFIG.GAME_CONFIG.SNAKE.boardSize;
                this.snake = [];
                this.direction = { x: 1, y: 0 };
                this.nextDirection = { x: 1, y: 0 };
                this.food = null;
                this.score = 0;
                this.gameInterval = null;
                this.gameSpeed = CONFIG.GAME_CONFIG.SNAKE.initialSpeed;
                this.isGameActive = false;
                this.storageKey = 'clock_snake_best';
            }

            init() {
                this.loadBestScore();
                this.setupEventListeners();
                this.renderBoard();
                this.updateStats();
            }

            setupEventListeners() {
                const startBtn = document.getElementById('startSnake');
                const resetBtn = document.getElementById('resetSnake');

                if (startBtn) {
                    startBtn.addEventListener('click', () => this.startGame());
                }

                if (resetBtn) {
                    resetBtn.addEventListener('click', () => this.resetGame());
                }

                document.addEventListener('keydown', (e) => {
                    if (!this.isGameActive) return;

                    const key = e.key.toLowerCase();
                    const newDirection = { ...this.nextDirection };

                    switch(key) {
                        case 'arrowup':
                        case 'w':
                            if (this.direction.y === 0) {
                                newDirection.x = 0;
                                newDirection.y = -1;
                            }
                            break;
                        case 'arrowdown':
                        case 's':
                            if (this.direction.y === 0) {
                                newDirection.x = 0;
                                newDirection.y = 1;
                            }
                            break;
                        case 'arrowleft':
                        case 'a':
                            if (this.direction.x === 0) {
                                newDirection.x = -1;
                                newDirection.y = 0;
                            }
                            break;
                        case 'arrowright':
                        case 'd':
                            if (this.direction.x === 0) {
                                newDirection.x = 1;
                                newDirection.y = 0;
                            }
                            break;
                    }

                    this.nextDirection = newDirection;
                });
            }

            startGame() {
                if (this.isGameActive) return;

                this.isGameActive = true;
                this.score = 0;
                this.direction = { x: 1, y: 0 };
                this.nextDirection = { x: 1, y: 0 };
                this.gameSpeed = CONFIG.GAME_CONFIG.SNAKE.initialSpeed;

                this.snake = [
                    { x: 7, y: 7 },
                    { x: 6, y: 7 },
                    { x: 5, y: 7 }
                ];

                this.spawnFood();
                this.renderBoard();
                this.updateStats();
                this.showMessage('Ê∏∏ÊàèÂºÄÂßãÔºÅ‰ΩøÁî®ÊñπÂêëÈîÆÊàñWASDÊéßÂà∂', 'info');
                this.startTimer();
            }

            resetGame() {
                this.stopTimer();
                this.isGameActive = false;
                this.score = 0;
                this.snake = [];
                this.direction = { x: 1, y: 0 };
                this.nextDirection = { x: 1, y: 0 };
                this.food = null;

                this.renderBoard();
                this.updateStats();
                this.showMessage('ÁÇπÂáª"ÂºÄÂßãÊ∏∏Êàè"ÂºÄÂßãÊåëÊàòÔºÅ', 'info');
            }

            startTimer() {
                this.stopTimer();
                this.gameInterval = setInterval(() => {
                    this.update();
                }, this.gameSpeed);
            }

            stopTimer() {
                if (this.gameInterval) {
                    clearInterval(this.gameInterval);
                    this.gameInterval = null;
                }
            }

            spawnFood() {
                let newFood;
                do {
                    newFood = {
                        x: Math.floor(Math.random() * this.boardSize),
                        y: Math.floor(Math.random() * this.boardSize)
                    };
                } while (this.snake.some(segment => segment.x === newFood.x && segment.y === newFood.y));
                
                this.food = newFood;
            }

            update() {
                if (!this.isGameActive) return;

                this.direction = { ...this.nextDirection };

                const head = { ...this.snake[0] };
                head.x += this.direction.x;
                head.y += this.direction.y;

                if (head.x < 0 || head.x >= this.boardSize || head.y < 0 || head.y >= this.boardSize) {
                    this.gameOver();
                    return;
                }

                if (this.snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                    this.gameOver();
                    return;
                }

                this.snake.unshift(head);

                if (this.food && head.x === this.food.x && head.y === this.food.y) {
                    this.score += CONFIG.GAME_CONFIG.SNAKE.scorePerFood;
                    this.spawnFood();
                    
                    if (this.score % CONFIG.GAME_CONFIG.SNAKE.speedUpThreshold === 0 && this.gameSpeed > 50) {
                        this.gameSpeed -= CONFIG.GAME_CONFIG.SNAKE.speedIncrement;
                        this.startTimer();
                    }
                } else {
                    this.snake.pop();
                }

                this.renderBoard();
                this.updateStats();
            }

            renderBoard() {
                const board = document.getElementById('snakeBoard');
                if (!board) return;

                const fragment = document.createDocumentFragment();
                for (let y = 0; y < this.boardSize; y++) {
                    for (let x = 0; x < this.boardSize; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'snake-cell';
                        cell.setAttribute('role', 'gridcell');
                        cell.setAttribute('aria-label', `‰ΩçÁΩÆ ${x},${y}`);

                        const isSnake = this.snake.some(segment => segment.x === x && segment.y === y);
                        const isHead = this.snake.length > 0 && this.snake[0].x === x && this.snake[0].y === y;
                        const isFood = this.food && this.food.x === x && this.food.y === y;

                        if (isHead) {
                            cell.classList.add('snake-head');
                        } else if (isSnake) {
                            cell.classList.add('snake');
                        } else if (isFood) {
                            cell.classList.add('food');
                        }

                        fragment.appendChild(cell);
                    }
                }

                board.innerHTML = '';
                board.appendChild(fragment);
            }

            updateStats() {
                const scoreElement = document.getElementById('snakeScore');
                const lengthElement = document.getElementById('snakeLength');
                const bestElement = document.getElementById('snakeBest');

                if (scoreElement) scoreElement.textContent = this.score;
                if (lengthElement) lengthElement.textContent = this.snake.length;

                const bestScore = this.getBestScore();
                if (bestElement && bestScore) {
                    bestElement.textContent = `${bestScore.score}ÂàÜ/${bestScore.length}ËäÇ`;
                } else if (bestElement) {
                    bestElement.textContent = '--';
                }
            }

            showMessage(text, type = 'info') {
                const messageElement = document.getElementById('snakeMessage');
                if (!messageElement) return;

                messageElement.textContent = text;
                messageElement.className = `game-message ${type}`;
            }

            gameOver() {
                this.stopTimer();
                this.isGameActive = false;

                const bestScore = this.getBestScore();
                const isNewRecord = !bestScore || this.score > bestScore.score;

                if (isNewRecord) {
                    this.saveBestScore();
                    this.showMessage(`üíÄ Ê∏∏ÊàèÁªìÊùüÔºÅÊñ∞Á∫™ÂΩïÔºÅÂæóÂàÜÔºö${this.score}ÔºåÈïøÂ∫¶Ôºö${this.snake.length}ËäÇ`, 'success');
                } else {
                    this.showMessage(`üíÄ Ê∏∏ÊàèÁªìÊùüÔºÅÂæóÂàÜÔºö${this.score}ÔºåÈïøÂ∫¶Ôºö${this.snake.length}ËäÇ`, 'warning');
                }

                this.updateStats();
            }

            getBestScore() {
                try {
                    const data = localStorage.getItem(this.storageKey);
                    return data ? JSON.parse(data) : null;
                } catch (error) {
                    console.warn('Failed to load snake best score:', error);
                    return null;
                }
            }

            saveBestScore() {
                try {
                    const bestScore = {
                        score: this.score,
                        length: this.snake.length,
                        date: new Date().toISOString()
                    };
                    localStorage.setItem(this.storageKey, JSON.stringify(bestScore));
                } catch (error) {
                    console.warn('Failed to save snake best score:', error);
                }
            }

            loadBestScore() {
                // Â∑≤Âú®getBestScore‰∏≠Â§ÑÁêÜ
            }

            destroy() {
                this.stopTimer();
            }
        }

        // ‰∏≠ÂõΩË±°Ê£ãÊ∏∏ÊàèÔºàÁÆÄÂåñÁâàÔºâ- Â∏¶ÁîµËÑëAI
        class ChessGame {
            constructor() {
                this.board = [];
                this.currentPlayer = 'red';
                this.selectedPiece = null;
                this.gameActive = false;
                this.storageKey = 'clock_chess_best';
                this.moves = 0;
                this.isComputerTurn = false;
                this.computerDelay = 500; // ÁîµËÑëÊÄùËÄÉÂª∂Ëøü
            }

            init() {
                this.setupEventListeners();
                this.renderBoard();
                this.updateStats();
            }

            setupEventListeners() {
                const startBtn = document.getElementById('startChess');
                const resetBtn = document.getElementById('resetChess');

                if (startBtn) {
                    startBtn.addEventListener('click', () => this.startGame());
                }

                if (resetBtn) {
                    resetBtn.addEventListener('click', () => this.resetGame());
                }
            }

            startGame() {
                this.gameActive = true;
                this.currentPlayer = 'red';
                this.selectedPiece = null;
                this.moves = 0;
                this.initBoard();
                this.renderBoard();
                this.updateStats();
                this.showMessage('Á∫¢ÊñπÂÖàËµ∞ÔºÅ', 'info');
            }

            resetGame() {
                this.gameActive = false;
                this.selectedPiece = null;
                this.moves = 0;
                this.board = [];
                this.renderBoard();
                this.updateStats();
                this.showMessage('ÁÇπÂáª"ÂºÄÂßãÊ∏∏Êàè"ÂºÄÂßãÊåëÊàòÔºÅ', 'info');
            }

            initBoard() {
                // ÁÆÄÂåñÁâà‰∏≠ÂõΩË±°Ê£ãÊ£ãÁõò
                this.board = [
                    ['ËΩ¶', 'È©¨', 'Áõ∏', 'Â£´', 'Â∞Ü', 'Â£´', 'Áõ∏', 'È©¨', 'ËΩ¶'],
                    ['', '', '', '', '', '', '', '', ''],
                    ['', 'ÁÇÆ', '', '', '', '', '', 'ÁÇÆ', ''],
                    ['ÂÖµ', '', 'ÂÖµ', '', 'ÂÖµ', '', 'ÂÖµ', '', 'ÂÖµ'],
                    ['', '', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', '', ''],
                    ['Âçí', '', 'Âçí', '', 'Âçí', '', 'Âçí', '', 'Âçí'],
                    ['', 'Á†≤', '', '', '', '', '', 'Á†≤', ''],
                    ['', '', '', '', '', '', '', '', ''],
                    ['‰ø•', 'È¶¨', 'Ë±°', '‰ªï', 'Â∏•', '‰ªï', 'Ë±°', 'È¶¨', '‰ø•']
                ];
            }

            renderBoard() {
                const board = document.getElementById('chessBoard');
                if (!board) return;

                if (!this.gameActive) {
                    board.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 40px; color: var(--text-secondary);">ÁÇπÂáª"ÂºÄÂßãÊ∏∏Êàè"ÂºÄÂßãÊåëÊàò</div>';
                    return;
                }

                const fragment = document.createDocumentFragment();
                for (let y = 0; y < 10; y++) {
                    for (let x = 0; x < 9; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'chess-cell';
                        cell.setAttribute('role', 'gridcell');
                        cell.setAttribute('aria-label', `‰ΩçÁΩÆ ${x},${y}`);
                        
                        const piece = this.board[y][x];
                        if (piece) {
                            cell.textContent = piece;
                            if (this.isRedPiece(piece)) {
                                cell.classList.add('red-piece');
                            } else if (this.isBlackPiece(piece)) {
                                cell.classList.add('black-piece');
                            }
                        }

                        if (this.selectedPiece && this.selectedPiece.x === x && this.selectedPiece.y === y) {
                            cell.classList.add('selected');
                        }

                        cell.addEventListener('click', () => this.handleCellClick(x, y));
                        fragment.appendChild(cell);
                    }
                }

                board.innerHTML = '';
                board.appendChild(fragment);
            }

            handleCellClick(x, y) {
                if (!this.gameActive) return;

                const piece = this.board[y][x];

                // Â¶ÇÊûúÁÇπÂáª‰∫ÜÂ∑±ÊñπÊ£ãÂ≠êÔºåÈÄâ‰∏≠ÂÆÉ
                if (piece && this.isCurrentPlayerPiece(piece)) {
                    this.selectedPiece = { x, y };
                    this.renderBoard();
                    return;
                }

                // Â¶ÇÊûúÂ∑≤ÁªèÈÄâ‰∏≠‰∫ÜÊ£ãÂ≠êÔºåÂ∞ùËØïÁßªÂä®
                if (this.selectedPiece) {
                    if (this.isValidMove(this.selectedPiece.x, this.selectedPiece.y, x, y)) {
                        this.board[y][x] = this.board[this.selectedPiece.y][this.selectedPiece.x];
                        this.board[this.selectedPiece.y][this.selectedPiece.x] = '';
                        this.selectedPiece = null;
                        this.moves++;
                        
                        // Ê£ÄÊü•ÊòØÂê¶Ëé∑ËÉú
                        if (this.checkWin()) {
                            this.gameWon();
                            return;
                        }
                        
                        // ÂàáÊç¢Áé©ÂÆ∂
                        this.currentPlayer = this.currentPlayer === 'red' ? 'black' : 'red';
                        this.renderBoard();
                        this.updateStats();
                        this.showMessage(`${this.currentPlayer === 'red' ? 'Á∫¢' : 'Èªë'}ÊñπËµ∞Ê£ã`, 'info');
                    }
                }
            }

            isRedPiece(piece) {
                return ['ËΩ¶', 'È©¨', 'Áõ∏', 'Â£´', 'Â∞Ü', 'ÁÇÆ', 'ÂÖµ'].includes(piece);
            }

            isBlackPiece(piece) {
                return ['‰ø•', 'È¶¨', 'Ë±°', '‰ªï', 'Â∏•', 'Á†≤', 'Âçí'].includes(piece);
            }

            isCurrentPlayerPiece(piece) {
                if (this.currentPlayer === 'red') {
                    return this.isRedPiece(piece);
                } else {
                    return this.isBlackPiece(piece);
                }
            }

            isValidMove(fromX, fromY, toX, toY) {
                const piece = this.board[fromY][fromX];
                const target = this.board[toY][toX];

                // ‰∏çËÉΩÂêÉËá™Â∑±ÁöÑÊ£ãÂ≠ê
                if (target && this.isCurrentPlayerPiece(target)) {
                    return false;
                }

                // ÁÆÄÂåñÁßªÂä®ËßÑÂàô
                const dx = Math.abs(toX - fromX);
                const dy = Math.abs(toY - fromY);

                // ËΩ¶/‰ø•ÔºöÁõ¥Á∫øÁßªÂä®
                if (piece === 'ËΩ¶' || piece === '‰ø•') {
                    if (dx === 0 || dy === 0) {
                        return this.isPathClear(fromX, fromY, toX, toY);
                    }
                    return false;
                }

                // È©¨/È¶¨ÔºöÊó•Â≠óÁßªÂä®
                if (piece === 'È©¨' || piece === 'È¶¨') {
                    return (dx === 1 && dy === 2) || (dx === 2 && dy === 1);
                }

                // Áõ∏/Ë±°ÔºöÁî∞Â≠óÁßªÂä®
                if (piece === 'Áõ∏' || piece === 'Ë±°') {
                    return dx === 2 && dy === 2;
                }

                // Â£´/‰ªïÔºöÊñúÁ∫øÁßªÂä®
                if (piece === 'Â£´' || piece === '‰ªï') {
                    return dx === 1 && dy === 1;
                }

                // Â∞Ü/Â∏•Ôºö‰∏ÄÊ≠•ÁßªÂä®
                if (piece === 'Â∞Ü' || piece === 'Â∏•') {
                    return (dx === 1 && dy === 0) || (dx === 0 && dy === 1);
                }

                // ÁÇÆ/Á†≤ÔºöÁõ¥Á∫øÁßªÂä®ÔºåÂêÉÂ≠êÊó∂‰∏≠Èó¥ÂøÖÈ°ªÊúâ‰∏Ä‰∏™Ê£ãÂ≠ê
                if (piece === 'ÁÇÆ' || piece === 'Á†≤') {
                    if (dx === 0 || dy === 0) {
                        if (target) {
                            // ÂêÉÂ≠êÔºö‰∏≠Èó¥ÂøÖÈ°ªÊúâ‰∏Ä‰∏™Ê£ãÂ≠ê
                            return this.getPieceCount(fromX, fromY, toX, toY) === 1;
                        } else {
                            // ÁßªÂä®Ôºö‰∏≠Èó¥‰∏çËÉΩÊúâÊ£ãÂ≠ê
                            return this.isPathClear(fromX, fromY, toX, toY);
                        }
                    }
                    return false;
                }

                // ÂÖµ/ÂçíÔºöÂêëÂâçÁßªÂä®
                if (piece === 'ÂÖµ' || piece === 'Âçí') {
                    if (this.currentPlayer === 'red') {
                        return dy === 1 && dx === 0 && toY > fromY;
                    } else {
                        return dy === 1 && dx === 0 && toY < fromY;
                    }
                }

                return false;
            }

            isPathClear(fromX, fromY, toX, toY) {
                const dx = Math.sign(toX - fromX);
                const dy = Math.sign(toY - fromY);
                let x = fromX + dx;
                let y = fromY + dy;

                while (x !== toX || y !== toY) {
                    if (this.board[y][x] !== '') {
                        return false;
                    }
                    x += dx;
                    y += dy;
                }
                return true;
            }

            getPieceCount(fromX, fromY, toX, toY) {
                const dx = Math.sign(toX - fromX);
                const dy = Math.sign(toY - fromY);
                let x = fromX + dx;
                let y = fromY + dy;
                let count = 0;

                while (x !== toX || y !== toY) {
                    if (this.board[y][x] !== '') {
                        count++;
                    }
                    x += dx;
                    y += dy;
                }
                return count;
            }

            checkWin() {
                // ÁÆÄÂåñÔºöÂ¶ÇÊûúÂØπÊñπÂ∞Ü/Â∏•Ë¢´ÂêÉÊéâÔºåËé∑ËÉú
                const targetPiece = this.currentPlayer === 'red' ? 'Â∏•' : 'Â∞Ü';
                for (let y = 0; y < 10; y++) {
                    for (let x = 0; x < 9; x++) {
                        if (this.board[y][x] === targetPiece) {
                            return false;
                        }
                    }
                }
                return true;
            }

            gameWon() {
                this.gameActive = false;
                const winner = this.currentPlayer === 'red' ? 'Á∫¢Êñπ' : 'ÈªëÊñπ';
                this.showMessage(`üéâ ${winner}Ëé∑ËÉúÔºÅÊ≠•Êï∞Ôºö${this.moves}`, 'success');
                this.updateStats();
            }

            updateStats() {
                const movesElement = document.getElementById('chessMoves');
                const playerElement = document.getElementById('chessPlayer');
                const bestElement = document.getElementById('chessBest');

                if (movesElement) movesElement.textContent = this.moves;
                if (playerElement) playerElement.textContent = this.currentPlayer === 'red' ? 'Á∫¢Êñπ' : 'ÈªëÊñπ';

                const bestScore = this.getBestScore();
                if (bestElement && bestScore) {
                    bestElement.textContent = `${bestScore.moves}Ê≠•`;
                } else if (bestElement) {
                    bestElement.textContent = '--';
                }
            }

            showMessage(text, type = 'info') {
                const messageElement = document.getElementById('chessMessage');
                if (!messageElement) return;

                messageElement.textContent = text;
                messageElement.className = `game-message ${type}`;
            }

            getBestScore() {
                try {
                    const data = localStorage.getItem(this.storageKey);
                    return data ? JSON.parse(data) : null;
                } catch (error) {
                    console.warn('Failed to load chess best score:', error);
                    return null;
                }
            }

            saveBestScore() {
                try {
                    const bestScore = {
                        moves: this.moves,
                        date: new Date().toISOString()
                    };
                    localStorage.setItem(this.storageKey, JSON.stringify(bestScore));
                } catch (error) {
                    console.warn('Failed to save chess best score:', error);
                }
            }

            destroy() {
                // Ê∏ÖÁêÜËµÑÊ∫ê
            }
        }

        // ‰∫îÂ≠êÊ£ãÊ∏∏Êàè
        class GomokuGame {
            constructor() {
                this.boardSize = 15;
                this.board = [];
                this.currentPlayer = 'black';
                this.gameActive = false;
                this.storageKey = 'clock_gomoku_best';
                this.moves = 0;
            }

            init() {
                this.setupEventListeners();
                this.renderBoard();
                this.updateStats();
            }

            setupEventListeners() {
                const startBtn = document.getElementById('startGomoku');
                const resetBtn = document.getElementById('resetGomoku');

                if (startBtn) {
                    startBtn.addEventListener('click', () => this.startGame());
                }

                if (resetBtn) {
                    resetBtn.addEventListener('click', () => this.resetGame());
                }
            }

            startGame() {
                this.gameActive = true;
                this.currentPlayer = 'black';
                this.moves = 0;
                this.board = Array(this.boardSize).fill(null).map(() => Array(this.boardSize).fill(''));
                this.renderBoard();
                this.updateStats();
                this.showMessage('ÈªëÊñπÂÖàËµ∞ÔºÅ', 'info');
            }

            resetGame() {
                this.gameActive = false;
                this.moves = 0;
                this.board = [];
                this.renderBoard();
                this.updateStats();
                this.showMessage('ÁÇπÂáª"ÂºÄÂßãÊ∏∏Êàè"ÂºÄÂßãÊåëÊàòÔºÅ', 'info');
            }

            renderBoard() {
                const board = document.getElementById('gomokuBoard');
                if (!board) return;

                if (!this.gameActive) {
                    board.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 40px; color: var(--text-secondary);">ÁÇπÂáª"ÂºÄÂßãÊ∏∏Êàè"ÂºÄÂßãÊåëÊàò</div>';
                    return;
                }

                const fragment = document.createDocumentFragment();
                for (let y = 0; y < this.boardSize; y++) {
                    for (let x = 0; x < this.boardSize; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'gomoku-cell';
                        cell.setAttribute('role', 'gridcell');
                        cell.setAttribute('aria-label', `‰ΩçÁΩÆ ${x},${y}`);
                        
                        const piece = this.board[y][x];
                        if (piece) {
                            cell.textContent = piece;
                            if (piece === '‚óè') {
                                cell.classList.add('black-piece');
                            } else {
                                cell.classList.add('white-piece');
                            }
                        }

                        cell.addEventListener('click', () => this.handleCellClick(x, y));
                        fragment.appendChild(cell);
                    }
                }

                board.innerHTML = '';
                board.appendChild(fragment);
            }

            handleCellClick(x, y) {
                if (!this.gameActive) return;
                if (this.board[y][x] !== '') return;

                const piece = this.currentPlayer === 'black' ? '‚óè' : '‚óã';
                this.board[y][x] = piece;
                this.moves++;

                if (this.checkWin(x, y)) {
                    this.gameWon();
                    return;
                }

                this.currentPlayer = this.currentPlayer === 'black' ? 'white' : 'black';
                this.renderBoard();
                this.updateStats();
                this.showMessage(`${this.currentPlayer === 'black' ? 'Èªë' : 'ÁôΩ'}ÊñπËµ∞Ê£ã`, 'info');
            }

            checkWin(x, y) {
                const piece = this.board[y][x];
                const directions = [
                    [1, 0],   // Ê∞¥Âπ≥
                    [0, 1],   // ÂûÇÁõ¥
                    [1, 1],   // ÂØπËßíÁ∫ø
                    [1, -1]   // ÂèçÂØπËßíÁ∫ø
                ];

                for (const [dx, dy] of directions) {
                    let count = 1;
                    
                    // Ê≠£ÂêëÊ£ÄÊü•
                    let nx = x + dx;
                    let ny = y + dy;
                    while (nx >= 0 && nx < this.boardSize && ny >= 0 && ny < this.boardSize && 
                           this.board[ny][nx] === piece) {
                        count++;
                        nx += dx;
                        ny += dy;
                    }

                    // ÂèçÂêëÊ£ÄÊü•
                    nx = x - dx;
                    ny = y - dy;
                    while (nx >= 0 && nx < this.boardSize && ny >= 0 && ny < this.boardSize && 
                           this.board[ny][nx] === piece) {
                        count++;
                        nx -= dx;
                        ny -= dy;
                    }

                    if (count >= 5) {
                        return true;
                    }
                }

                return false;
            }

            gameWon() {
                this.gameActive = false;
                const winner = this.currentPlayer === 'black' ? 'ÈªëÊñπ' : 'ÁôΩÊñπ';
                this.showMessage(`üéâ ${winner}Ëé∑ËÉúÔºÅÊ≠•Êï∞Ôºö${this.moves}`, 'success');
                this.updateStats();
            }

            updateStats() {
                const movesElement = document.getElementById('gomokuMoves');
                const playerElement = document.getElementById('gomokuPlayer');
                const bestElement = document.getElementById('gomokuBest');

                if (movesElement) movesElement.textContent = this.moves;
                if (playerElement) playerElement.textContent = this.currentPlayer === 'black' ? 'ÈªëÊñπ' : 'ÁôΩÊñπ';

                const bestScore = this.getBestScore();
                if (bestElement && bestScore) {
                    bestElement.textContent = `${bestScore.moves}Ê≠•`;
                } else if (bestElement) {
                    bestElement.textContent = '--';
                }
            }

            showMessage(text, type = 'info') {
                const messageElement = document.getElementById('gomokuMessage');
                if (!messageElement) return;

                messageElement.textContent = text;
                messageElement.className = `game-message ${type}`;
            }

            getBestScore() {
                try {
                    const data = localStorage.getItem(this.storageKey);
                    return data ? JSON.parse(data) : null;
                } catch (error) {
                    console.warn('Failed to load gomoku best score:', error);
                    return null;
                }
            }

            saveBestScore() {
                try {
                    const bestScore = {
                        moves: this.moves,
                        date: new Date().toISOString()
                    };
                    localStorage.setItem(this.storageKey, JSON.stringify(bestScore));
                } catch (error) {
                    console.warn('Failed to save gomoku best score:', error);
                }
            }

            destroy() {
                // Ê∏ÖÁêÜËµÑÊ∫ê
            }
        }

        class SokobanGame {
            constructor() {
                this.boardSize = CONFIG.GAME_CONFIG.SOKOBAN.boardSize;
                this.currentLevel = 1;
                this.moves = 0;
                this.gameInterval = null;
                this.isGameActive = false;
                this.storageKey = 'clock_sokoban_best';
                this.levels = CONFIG.GAME_CONFIG.SOKOBAN.levels;
            }

            init() {
                this.loadBestScore();
                this.setupEventListeners();
                this.renderBoard();
                this.updateStats();
            }

            setupEventListeners() {
                const startBtn = document.getElementById('startSokoban');
                const resetBtn = document.getElementById('resetSokoban');
                const nextBtn = document.getElementById('nextLevel');

                if (startBtn) {
                    startBtn.addEventListener('click', () => this.startGame());
                }

                if (resetBtn) {
                    resetBtn.addEventListener('click', () => this.resetGame());
                }

                if (nextBtn) {
                    nextBtn.addEventListener('click', () => this.nextLevel());
                }

                document.addEventListener('keydown', (e) => {
                    if (!this.isGameActive) return;

                    const key = e.key.toLowerCase();
                    let dx = 0, dy = 0;

                    switch(key) {
                        case 'arrowup':
                        case 'w':
                            dy = -1;
                            break;
                        case 'arrowdown':
                        case 's':
                            dy = 1;
                            break;
                        case 'arrowleft':
                        case 'a':
                            dx = -1;
                            break;
                        case 'arrowright':
                        case 'd':
                            dx = 1;
                            break;
                        default:
                            return;
                    }

                    e.preventDefault();
                    this.movePlayer(dx, dy);
                });
            }

            startGame() {
                if (this.isGameActive) return;

                this.isGameActive = true;
                this.moves = 0;
                this.currentLevel = 1;

                this.renderBoard();
                this.updateStats();
                this.showMessage('Ê∏∏ÊàèÂºÄÂßãÔºÅ‰ΩøÁî®ÊñπÂêëÈîÆÊàñWASDÁßªÂä®', 'info');
            }

            resetGame() {
                this.isGameActive = false;
                this.moves = 0;
                this.currentLevel = 1;

                this.renderBoard();
                this.updateStats();
                this.showMessage('ÁÇπÂáª"ÂºÄÂßãÊ∏∏Êàè"ÂºÄÂßãÊåëÊàòÔºÅ', 'info');
            }

            nextLevel() {
                if (!this.isGameActive) {
                    this.showMessage('ËØ∑ÂÖàÂºÄÂßãÊ∏∏ÊàèÔºÅ', 'warning');
                    return;
                }

                if (this.currentLevel < this.levels.length) {
                    this.currentLevel++;
                    this.moves = 0;
                    this.renderBoard();
                    this.updateStats();
                    this.showMessage(`ËøõÂÖ•Á¨¨${this.currentLevel}ÂÖ≥ÔºÅ`, 'info');
                } else {
                    this.showMessage('üéâ ÊÅ≠ÂñúÔºÅ‰Ω†Â∑≤ÂÆåÊàêÊâÄÊúâÂÖ≥Âç°ÔºÅ', 'success');
                }
            }

            movePlayer(dx, dy) {
                const level = this.levels[this.currentLevel - 1];
                const player = { ...level.player };
                const newPlayer = { x: player.x + dx, y: player.y + dy };

                if (newPlayer.x < 0 || newPlayer.x >= this.boardSize || 
                    newPlayer.y < 0 || newPlayer.y >= this.boardSize) {
                    return;
                }

                if (level.map[newPlayer.y][newPlayer.x] === 1) {
                    return;
                }

                const boxIndex = level.boxes.findIndex(box => box.x === newPlayer.x && box.y === newPlayer.y);
                
                if (boxIndex !== -1) {
                    const newBox = { x: newPlayer.x + dx, y: newPlayer.y + dy };

                    if (newBox.x < 0 || newBox.x >= this.boardSize || 
                        newBox.y < 0 || newBox.y >= this.boardSize) {
                        return;
                    }

                    if (level.map[newBox.y][newBox.x] === 1) {
                        return;
                    }

                    if (level.boxes.some(box => box.x === newBox.x && box.y === newBox.y)) {
                        return;
                    }

                    level.boxes[boxIndex] = newBox;
                }

                level.player = newPlayer;
                this.moves++;

                this.renderBoard();
                this.updateStats();

                if (this.checkWin()) {
                    this.gameWon();
                }
            }

            checkWin() {
                const level = this.levels[this.currentLevel - 1];
                return level.boxes.every(box => 
                    level.targets.some(target => target.x === box.x && target.y === box.y)
                );
            }

            gameWon() {
                this.isGameActive = false;

                const bestScore = this.getBestScore();
                const isNewRecord = !bestScore || this.moves < bestScore.moves;

                if (isNewRecord) {
                    this.saveBestScore();
                    this.showMessage(`üéâ ÊÅ≠ÂñúÈÄöÂÖ≥ÔºÅÊñ∞Á∫™ÂΩïÔºÅÊ≠•Êï∞Ôºö${this.moves}`, 'success');
                } else {
                    this.showMessage(`üéâ ÈÄöÂÖ≥ÊàêÂäüÔºÅÊ≠•Êï∞Ôºö${this.moves}`, 'success');
                }

                this.updateStats();
            }

            renderBoard() {
                const board = document.getElementById('sokobanBoard');
                if (!board) return;

                if (!this.isGameActive) {
                    board.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 40px; color: var(--text-secondary);">ÁÇπÂáª"ÂºÄÂßãÊ∏∏Êàè"ÂºÄÂßãÊåëÊàò</div>';
                    return;
                }

                const level = this.levels[this.currentLevel - 1];
                const fragment = document.createDocumentFragment();

                for (let y = 0; y < this.boardSize; y++) {
                    for (let x = 0; x < this.boardSize; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'sokoban-cell';
                        cell.setAttribute('role', 'gridcell');
                        cell.setAttribute('aria-label', `‰ΩçÁΩÆ ${x},${y}`);

                        const isWall = level.map[y][x] === 1;
                        const isTarget = level.targets.some(t => t.x === x && t.y === y);
                        const isBox = level.boxes.some(b => b.x === x && b.y === y);
                        const isPlayer = level.player.x === x && level.player.y === y;

                        if (isWall) {
                            cell.classList.add('wall');
                            cell.textContent = '‚ñà';
                        } else if (isPlayer && isTarget) {
                            cell.classList.add('player');
                            cell.textContent = '‚óé';
                        } else if (isPlayer) {
                            cell.classList.add('player');
                            cell.textContent = '‚óè';
                        } else if (isBox && isTarget) {
                            cell.classList.add('box-on-target');
                            cell.textContent = '‚ñ†';
                        } else if (isBox) {
                            cell.classList.add('box');
                            cell.textContent = '‚ñ°';
                        } else if (isTarget) {
                            cell.classList.add('target');
                            cell.textContent = '‚óã';
                        } else {
                            cell.classList.add('floor');
                            cell.textContent = '';
                        }

                        fragment.appendChild(cell);
                    }
                }

                board.innerHTML = '';
                board.appendChild(fragment);
            }

            updateStats() {
                const levelElement = document.getElementById('sokobanLevel');
                const movesElement = document.getElementById('sokobanMoves');
                const bestElement = document.getElementById('sokobanBest');

                if (levelElement) levelElement.textContent = this.currentLevel;
                if (movesElement) movesElement.textContent = this.moves;

                const bestScore = this.getBestScore();
                if (bestElement && bestScore) {
                    bestElement.textContent = `${bestScore.moves}Ê≠•`;
                } else if (bestElement) {
                    bestElement.textContent = '--';
                }
            }

            showMessage(text, type = 'info') {
                const messageElement = document.getElementById('sokobanMessage');
                if (!messageElement) return;

                messageElement.textContent = text;
                messageElement.className = `game-message ${type}`;
            }

            getBestScore() {
                try {
                    const data = localStorage.getItem(this.storageKey);
                    return data ? JSON.parse(data) : null;
                } catch (error) {
                    console.warn('Failed to load sokoban best score:', error);
                    return null;
                }
            }

            saveBestScore() {
                try {
                    const bestScore = {
                        moves: this.moves,
                        level: this.currentLevel,
                        date: new Date().toISOString()
                    };
                    localStorage.setItem(this.storageKey, JSON.stringify(bestScore));
                } catch (error) {
                    console.warn('Failed to save sokoban best score:', error);
                }
            }

            loadBestScore() {
                // Â∑≤Âú®getBestScore‰∏≠Â§ÑÁêÜ
            }

            destroy() {
                // Ê∏ÖÁêÜËµÑÊ∫ê
            }
        }

        // ==================== Ê∏∏ÊàèÊ®°Âùó - Êñ∞Â¢ûÊ∏∏Êàè ====================
        
        // ‰øÑÁΩóÊñØÊñπÂùóÊ∏∏Êàè - Â§çÊùÇÁâà
        class TetrisGame {
            constructor() {
                this.boardWidth = 10;
                this.boardHeight = 20;
                this.board = [];
                this.currentPiece = null;
                this.currentX = 0;
                this.currentY = 0;
                this.gameInterval = null;
                this.gameSpeed = 500;
                this.score = 0;
                this.level = 1;
                this.lines = 0;
                this.isGameActive = false;
                this.storageKey = 'clock_tetris_best';
                this.nextPiece = null;
                this.holdPiece = null;
                this.canHold = true;
                this.combo = 0;
                this.backToBack = false;
                this.tSpin = false;
                this.bag = [];
                this.bagIndex = 0;
                
                // ÊñπÂùóÂΩ¢Áä∂ÔºàÂåÖÂê´ÊóãËΩ¨Áä∂ÊÄÅÔºâ
                this.shapes = {
                    I: [
                        [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
                        [[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]],
                        [[0,0,0,0],[0,0,0,0],[1,1,1,1],[0,0,0,0]],
                        [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]]
                    ],
                    O: [
                        [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
                        [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
                        [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
                        [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]]
                    ],
                    T: [
                        [[0,1,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
                        [[0,1,0,0],[0,1,1,0],[0,1,0,0],[0,0,0,0]],
                        [[0,0,0,0],[1,1,1,0],[0,1,0,0],[0,0,0,0]],
                        [[0,1,0,0],[1,1,0,0],[0,1,0,0],[0,0,0,0]]
                    ],
                    S: [
                        [[0,1,1,0],[1,1,0,0],[0,0,0,0],[0,0,0,0]],
                        [[0,1,0,0],[0,1,1,0],[0,0,1,0],[0,0,0,0]],
                        [[0,0,0,0],[0,1,1,0],[1,1,0,0],[0,0,0,0]],
                        [[1,0,0,0],[1,1,0,0],[0,1,0,0],[0,0,0,0]]
                    ],
                    Z: [
                        [[1,1,0,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
                        [[0,0,1,0],[0,1,1,0],[0,1,0,0],[0,0,0,0]],
                        [[0,0,0,0],[1,1,0,0],[0,1,1,0],[0,0,0,0]],
                        [[0,1,0,0],[1,1,0,0],[1,0,0,0],[0,0,0,0]]
                    ],
                    J: [
                        [[1,0,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
                        [[0,1,1,0],[0,1,0,0],[0,1,0,0],[0,0,0,0]],
                        [[0,0,0,0],[1,1,1,0],[0,0,1,0],[0,0,0,0]],
                        [[0,1,0,0],[0,1,0,0],[1,1,0,0],[0,0,0,0]]
                    ],
                    L: [
                        [[0,0,1,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
                        [[0,1,0,0],[0,1,0,0],[0,1,1,0],[0,0,0,0]],
                        [[0,0,0,0],[1,1,1,0],[1,0,0,0],[0,0,0,0]],
                        [[1,1,0,0],[0,1,0,0],[0,1,0,0],[0,0,0,0]]
                    ]
                };
                
                this.shapeColors = {
                    I: '#00f0f0',
                    O: '#f0f000',
                    T: '#a000f0',
                    S: '#00f000',
                    Z: '#f00000',
                    J: '#0000f0',
                    L: '#f0a000'
                };
            }

            init() {
                this.loadBestScore();
                this.setupEventListeners();
                this.renderBoard();
                this.updateStats();
            }

            setupEventListeners() {
                const startBtn = document.getElementById('startTetris');
                const resetBtn = document.getElementById('resetTetris');

                if (startBtn) {
                    startBtn.addEventListener('click', () => this.startGame());
                }

                if (resetBtn) {
                    resetBtn.addEventListener('click', () => this.resetGame());
                }

                document.addEventListener('keydown', (e) => {
                    if (!this.isGameActive) return;

                    switch(e.key) {
                        case 'ArrowLeft':
                            e.preventDefault();
                            this.movePiece(-1, 0);
                            break;
                        case 'ArrowRight':
                            e.preventDefault();
                            this.movePiece(1, 0);
                            break;
                        case 'ArrowDown':
                            e.preventDefault();
                            this.movePiece(0, 1);
                            break;
                        case 'ArrowUp':
                            e.preventDefault();
                            this.rotatePiece();
                            break;
                        case ' ':
                            e.preventDefault();
                            this.hardDrop();
                            break;
                    }
                });
            }

            startGame() {
                if (this.isGameActive) return;

                this.isGameActive = true;
                this.score = 0;
                this.level = 1;
                this.lines = 0;
                this.gameSpeed = 500;
                this.combo = 0;
                this.backToBack = false;
                this.tSpin = false;
                this.board = Array(this.boardHeight).fill(null).map(() => Array(this.boardWidth).fill(0));
                
                this.spawnPiece();
                this.renderBoard();
                this.updateStats();
                this.showMessage('Ê∏∏ÊàèÂºÄÂßãÔºÅ‰ΩøÁî®ÊñπÂêëÈîÆÊéßÂà∂', 'info');
                this.startTimer();
            }

            resetGame() {
                this.stopTimer();
                this.isGameActive = false;
                this.score = 0;
                this.level = 1;
                this.lines = 0;
                this.board = [];
                this.currentPiece = null;
                this.nextPiece = null;

                this.renderBoard();
                this.updateStats();
                this.showMessage('ÁÇπÂáª"ÂºÄÂßãÊ∏∏Êàè"ÂºÄÂßãÊåëÊàòÔºÅ', 'info');
            }

            startTimer() {
                this.stopTimer();
                this.gameInterval = setInterval(() => {
                    this.update();
                }, this.gameSpeed);
            }

            stopTimer() {
                if (this.gameInterval) {
                    clearInterval(this.gameInterval);
                    this.gameInterval = null;
                }
            }

            spawnPiece() {
                const shapes = Object.keys(this.shapes);
                const randomShape = shapes[Math.floor(Math.random() * shapes.length)];
                
                if (!this.nextPiece) {
                    this.nextPiece = {
                        shape: randomShape,
                        matrix: this.shapes[randomShape].map(row => [...row])
                    };
                }
                
                this.currentPiece = this.nextPiece;
                this.nextPiece = {
                    shape: shapes[Math.floor(Math.random() * shapes.length)],
                    matrix: this.shapes[shapes[Math.floor(Math.random() * shapes.length)]].map(row => [...row])
                };
                
                this.currentX = Math.floor((this.boardWidth - this.currentPiece.matrix[0].length) / 2);
                this.currentY = 0;

                if (this.checkCollision(this.currentX, this.currentY, this.currentPiece.matrix)) {
                    this.gameOver();
                }
            }

            update() {
                if (!this.isGameActive) return;

                if (!this.movePiece(0, 1)) {
                    this.lockPiece();
                    this.clearLines();
                    this.spawnPiece();
                }
            }

            movePiece(dx, dy) {
                const newX = this.currentX + dx;
                const newY = this.currentY + dy;

                if (!this.checkCollision(newX, newY, this.currentPiece.matrix)) {
                    this.currentX = newX;
                    this.currentY = newY;
                    this.renderBoard();
                    return true;
                }
                return false;
            }

            rotatePiece() {
                const rotated = this.rotateMatrix(this.currentPiece.matrix);
                if (!this.checkCollision(this.currentX, this.currentY, rotated)) {
                    this.currentPiece.matrix = rotated;
                    this.renderBoard();
                }
            }

            rotateMatrix(matrix) {
                const rows = matrix.length;
                const cols = matrix[0].length;
                const rotated = Array(cols).fill(null).map(() => Array(rows).fill(0));
                
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        rotated[x][rows - 1 - y] = matrix[y][x];
                    }
                }
                return rotated;
            }

            hardDrop() {
                while (this.movePiece(0, 1)) {}
            }

            checkCollision(x, y, matrix) {
                for (let row = 0; row < matrix.length; row++) {
                    for (let col = 0; col < matrix[row].length; col++) {
                        if (matrix[row][col]) {
                            const newX = x + col;
                            const newY = y + row;
                            
                            if (newX < 0 || newX >= this.boardWidth || newY >= this.boardHeight) {
                                return true;
                            }
                            
                            if (newY >= 0 && this.board[newY][newX]) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            lockPiece() {
                for (let row = 0; row < this.currentPiece.matrix.length; row++) {
                    for (let col = 0; col < this.currentPiece.matrix[row].length; col++) {
                        if (this.currentPiece.matrix[row][col]) {
                            const y = this.currentY + row;
                            const x = this.currentX + col;
                            if (y >= 0) {
                                this.board[y][x] = this.currentPiece.shape;
                            }
                        }
                    }
                }
            }

            clearLines() {
                let linesCleared = 0;
                for (let y = this.boardHeight - 1; y >= 0; y--) {
                    if (this.board[y].every(cell => cell !== 0)) {
                        this.board.splice(y, 1);
                        this.board.unshift(Array(this.boardWidth).fill(0));
                        linesCleared++;
                        y++;
                    }
                }

                if (linesCleared > 0) {
                    this.lines += linesCleared;
                    this.score += [0, 100, 300, 500, 800][linesCleared] * this.level;
                    
                    if (this.lines >= this.level * 10) {
                        this.level++;
                        this.gameSpeed = Math.max(100, 500 - (this.level - 1) * 50);
                        this.startTimer();
                    }

                    this.updateStats();
                }
            }

            gameOver() {
                this.stopTimer();
                this.isGameActive = false;

                const bestScore = this.getBestScore();
                const isNewRecord = !bestScore || this.score > bestScore.score;

                if (isNewRecord) {
                    this.saveBestScore();
                    this.showMessage(`üíÄ Ê∏∏ÊàèÁªìÊùüÔºÅÊñ∞Á∫™ÂΩïÔºÅÂæóÂàÜÔºö${this.score}ÔºåÁ≠âÁ∫ßÔºö${this.level}`, 'success');
                } else {
                    this.showMessage(`üíÄ Ê∏∏ÊàèÁªìÊùüÔºÅÂæóÂàÜÔºö${this.score}ÔºåÁ≠âÁ∫ßÔºö${this.level}`, 'warning');
                }

                this.updateStats();
            }

            renderBoard() {
                const board = document.getElementById('tetrisBoard');
                if (!board) return;

                if (!this.isGameActive) {
                    board.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 40px; color: var(--text-secondary);">ÁÇπÂáª"ÂºÄÂßãÊ∏∏Êàè"ÂºÄÂßãÊåëÊàò</div>';
                    return;
                }

                const fragment = document.createDocumentFragment();
                
                // ÁªòÂà∂Ê∏∏ÊàèÊùø
                for (let y = 0; y < this.boardHeight; y++) {
                    for (let x = 0; x < this.boardWidth; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'tetris-cell';
                        cell.setAttribute('role', 'gridcell');
                        cell.setAttribute('aria-label', `‰ΩçÁΩÆ ${x},${y}`);
                        
                        const cellValue = this.board[y][x];
                        if (cellValue) {
                            cell.style.backgroundColor = this.shapeColors[cellValue];
                            cell.style.boxShadow = `inset 0 0 5px rgba(0,0,0,0.3)`;
                        }

                        // ÁªòÂà∂ÂΩìÂâçÊñπÂùó
                        if (this.currentPiece && y >= this.currentY && y < this.currentY + this.currentPiece.matrix.length &&
                            x >= this.currentX && x < this.currentX + this.currentPiece.matrix[0].length) {
                            const relY = y - this.currentY;
                            const relX = x - this.currentX;
                            if (this.currentPiece.matrix[relY][relX]) {
                                cell.style.backgroundColor = this.shapeColors[this.currentPiece.shape];
                                cell.style.boxShadow = `inset 0 0 5px rgba(0,0,0,0.3)`;
                            }
                        }

                        fragment.appendChild(cell);
                    }
                }

                board.innerHTML = '';
                board.appendChild(fragment);
            }

            updateStats() {
                const scoreElement = document.getElementById('tetrisScore');
                const levelElement = document.getElementById('tetrisLevel');
                const linesElement = document.getElementById('tetrisLines');
                const bestElement = document.getElementById('tetrisBest');

                if (scoreElement) scoreElement.textContent = this.score;
                if (levelElement) levelElement.textContent = this.level;
                if (linesElement) linesElement.textContent = this.lines;

                const bestScore = this.getBestScore();
                if (bestElement && bestScore) {
                    bestElement.textContent = `${bestScore.score}ÂàÜ`;
                } else if (bestElement) {
                    bestElement.textContent = '--';
                }
            }

            showMessage(text, type = 'info') {
                const messageElement = document.getElementById('tetrisMessage');
                if (!messageElement) return;

                messageElement.textContent = text;
                messageElement.className = `game-message ${type}`;
            }

            getBestScore() {
                try {
                    const data = localStorage.getItem(this.storageKey);
                    return data ? JSON.parse(data) : null;
                } catch (error) {
                    console.warn('Failed to load tetris best score:', error);
                    return null;
                }
            }

            saveBestScore() {
                try {
                    const bestScore = {
                        score: this.score,
                        level: this.level,
                        lines: this.lines,
                        date: new Date().toISOString()
                    };
                    localStorage.setItem(this.storageKey, JSON.stringify(bestScore));
                } catch (error) {
                    console.warn('Failed to save tetris best score:', error);
                }
            }

            loadBestScore() {
                // Â∑≤Âú®getBestScore‰∏≠Â§ÑÁêÜ
            }

            destroy() {
                this.stopTimer();
            }
        }

        // Êâ´Èõ∑Ê∏∏Êàè
        class MinesweeperGame {
            constructor() {
                this.boardWidth = 10;
                this.boardHeight = 10;
                this.mineCount = 15;
                this.board = [];
                this.revealed = [];
                this.flags = [];
                this.gameActive = false;
                this.storageKey = 'clock_minesweeper_best';
                this.startTime = null;
                this.timer = null;
                this.gameTime = 0;
            }

            init() {
                this.loadBestScore();
                this.setupEventListeners();
                this.renderBoard();
                this.updateStats();
            }

            setupEventListeners() {
                const startBtn = document.getElementById('startMinesweeper');
                const resetBtn = document.getElementById('resetMinesweeper');

                if (startBtn) {
                    startBtn.addEventListener('click', () => this.startGame());
                }

                if (resetBtn) {
                    resetBtn.addEventListener('click', () => this.resetGame());
                }
            }

            startGame() {
                if (this.gameActive) return;

                this.gameActive = true;
                this.gameTime = 0;
                this.board = Array(this.boardHeight).fill(null).map(() => Array(this.boardWidth).fill(0));
                this.revealed = Array(this.boardHeight).fill(null).map(() => Array(this.boardWidth).fill(false));
                this.flags = Array(this.boardHeight).fill(null).map(() => Array(this.boardWidth).fill(false));

                this.placeMines();
                this.calculateNumbers();
                this.renderBoard();
                this.updateStats();
                this.showMessage('Ê∏∏ÊàèÂºÄÂßãÔºÅÂ∑¶ÈîÆÁøªÂºÄÔºåÂè≥ÈîÆÊ†áËÆ∞', 'info');
                this.startTimer();
            }

            resetGame() {
                this.stopTimer();
                this.gameActive = false;
                this.gameTime = 0;
                this.board = [];
                this.revealed = [];
                this.flags = [];

                this.renderBoard();
                this.updateStats();
                this.showMessage('ÁÇπÂáª"ÂºÄÂßãÊ∏∏Êàè"ÂºÄÂßãÊåëÊàòÔºÅ', 'info');
            }

            startTimer() {
                this.stopTimer();
                this.timer = setInterval(() => {
                    this.gameTime++;
                    this.updateStats();
                }, 1000);
            }

            stopTimer() {
                if (this.timer) {
                    clearInterval(this.timer);
                    this.timer = null;
                }
            }

            placeMines() {
                let minesPlaced = 0;
                while (minesPlaced < this.mineCount) {
                    const x = Math.floor(Math.random() * this.boardWidth);
                    const y = Math.floor(Math.random() * this.boardHeight);
                    if (this.board[y][x] !== -1) {
                        this.board[y][x] = -1;
                        minesPlaced++;
                    }
                }
            }

            calculateNumbers() {
                for (let y = 0; y < this.boardHeight; y++) {
                    for (let x = 0; x < this.boardWidth; x++) {
                        if (this.board[y][x] === -1) continue;
                        
                        let count = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const ny = y + dy;
                                const nx = x + dx;
                                if (ny >= 0 && ny < this.boardHeight && nx >= 0 && nx < this.boardWidth) {
                                    if (this.board[ny][nx] === -1) count++;
                                }
                            }
                        }
                        this.board[y][x] = count;
                    }
                }
            }

            reveal(x, y) {
                if (!this.gameActive || x < 0 || x >= this.boardWidth || y < 0 || y >= this.boardHeight) return;
                if (this.revealed[y][x] || this.flags[y][x]) return;

                this.revealed[y][x] = true;

                if (this.board[y][x] === -1) {
                    this.gameOver(false);
                    return;
                }

                if (this.board[y][x] === 0) {
                    // ÈÄíÂΩíÊè≠Á§∫Âë®Âõ¥
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx !== 0 || dy !== 0) {
                                this.reveal(x + dx, y + dy);
                            }
                        }
                    }
                }

                this.renderBoard();
                this.checkWin();
            }

            toggleFlag(x, y) {
                if (!this.gameActive || x < 0 || x >= this.boardWidth || y < 0 || y >= this.boardHeight) return;
                if (this.revealed[y][x]) return;

                this.flags[y][x] = !this.flags[y][x];
                this.renderBoard();
                this.updateStats();
            }

            checkWin() {
                let revealedCount = 0;
                for (let y = 0; y < this.boardHeight; y++) {
                    for (let x = 0; x < this.boardWidth; x++) {
                        if (this.revealed[y][x]) revealedCount++;
                    }
                }

                if (revealedCount === this.boardWidth * this.boardHeight - this.mineCount) {
                    this.gameOver(true);
                }
            }

            gameOver(won) {
                this.stopTimer();
                this.gameActive = false;

                if (won) {
                    const bestScore = this.getBestScore();
                    const isNewRecord = !bestScore || this.gameTime < bestScore.time;

                    if (isNewRecord) {
                        this.saveBestScore();
                        this.showMessage(`üéâ ÊÅ≠ÂñúËé∑ËÉúÔºÅÊñ∞Á∫™ÂΩïÔºÅÊó∂Èó¥Ôºö${this.gameTime}Áßí`, 'success');
                    } else {
                        this.showMessage(`üéâ Ëé∑ËÉúÔºÅÊó∂Èó¥Ôºö${this.gameTime}Áßí`, 'success');
                    }
                } else {
                    // ÊòæÁ§∫ÊâÄÊúâÂú∞Èõ∑
                    for (let y = 0; y < this.boardHeight; y++) {
                        for (let x = 0; x < this.boardWidth; x++) {
                            if (this.board[y][x] === -1) {
                                this.revealed[y][x] = true;
                            }
                        }
                    }
                    this.renderBoard();
                    this.showMessage(`üí• Ê∏∏ÊàèÁªìÊùüÔºÅË∏©Âà∞Âú∞Èõ∑‰∫Ü`, 'warning');
                }

                this.updateStats();
            }

            renderBoard() {
                const board = document.getElementById('minesweeperBoard');
                if (!board) return;

                if (!this.gameActive && this.board.length === 0) {
                    board.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 40px; color: var(--text-secondary);">ÁÇπÂáª"ÂºÄÂßãÊ∏∏Êàè"ÂºÄÂßãÊåëÊàò</div>';
                    return;
                }

                const fragment = document.createDocumentFragment();
                
                for (let y = 0; y < this.boardHeight; y++) {
                    for (let x = 0; x < this.boardWidth; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'minesweeper-cell';
                        cell.setAttribute('role', 'gridcell');
                        cell.setAttribute('aria-label', `‰ΩçÁΩÆ ${x},${y}`);
                        
                        if (this.revealed[y][x]) {
                            if (this.board[y][x] === -1) {
                                cell.classList.add('mine');
                                cell.textContent = 'üí£';
                            } else if (this.board[y][x] > 0) {
                                cell.classList.add(`number-${this.board[y][x]}`);
                                cell.textContent = this.board[y][x];
                            } else {
                                cell.classList.add('revealed');
                            }
                        } else if (this.flags[y][x]) {
                            cell.classList.add('flag');
                            cell.textContent = 'üö©';
                        }

                        if (this.gameActive) {
                            cell.addEventListener('click', (e) => {
                                e.preventDefault();
                                this.reveal(x, y);
                            });
                            cell.addEventListener('contextmenu', (e) => {
                                e.preventDefault();
                                this.toggleFlag(x, y);
                            });
                        }

                        fragment.appendChild(cell);
                    }
                }

                board.innerHTML = '';
                board.appendChild(fragment);
            }

            updateStats() {
                const timeElement = document.getElementById('minesweeperTime');
                const flagsElement = document.getElementById('minesweeperFlags');
                const bestElement = document.getElementById('minesweeperBest');

                if (timeElement) timeElement.textContent = `${this.gameTime}s`;
                if (flagsElement) flagsElement.textContent = `${this.mineCount - this.flags.flat().filter(f => f).length}`;

                const bestScore = this.getBestScore();
                if (bestElement && bestScore) {
                    bestElement.textContent = `${bestScore.time}Áßí`;
                } else if (bestElement) {
                    bestElement.textContent = '--';
                }
            }

            showMessage(text, type = 'info') {
                const messageElement = document.getElementById('minesweeperMessage');
                if (!messageElement) return;

                messageElement.textContent = text;
                messageElement.className = `game-message ${type}`;
            }

            getBestScore() {
                try {
                    const data = localStorage.getItem(this.storageKey);
                    return data ? JSON.parse(data) : null;
                } catch (error) {
                    console.warn('Failed to load minesweeper best score:', error);
                    return null;
                }
            }

            saveBestScore() {
                try {
                    const bestScore = {
                        time: this.gameTime,
                        date: new Date().toISOString()
                    };
                    localStorage.setItem(this.storageKey, JSON.stringify(bestScore));
                } catch (error) {
                    console.warn('Failed to save minesweeper best score:', error);
                }
            }

            loadBestScore() {
                // Â∑≤Âú®getBestScore‰∏≠Â§ÑÁêÜ
            }

            destroy() {
                this.stopTimer();
            }
        }

        // ‰∫ïÂ≠óÊ£ãÊ∏∏Êàè - Â∏¶ÁîµËÑëAI
        class TicTacToeGame {
            constructor() {
                this.board = Array(3).fill(null).map(() => Array(3).fill(''));
                this.currentPlayer = 'X';
                this.gameActive = false;
                this.storageKey = 'clock_tictactoe_best';
                this.moves = 0;
                this.isComputerTurn = false;
                this.computerDelay = 500;
                this.mode = 'computer'; // 'computer' Êàñ 'human'
            }

            init() {
                this.loadBestScore();
                this.setupEventListeners();
                this.renderBoard();
                this.updateStats();
            }

            setupEventListeners() {
                const startBtn = document.getElementById('startTicTacToe');
                const resetBtn = document.getElementById('resetTicTacToe');
                const modeBtn = document.getElementById('toggleTicTacToeMode');

                if (startBtn) {
                    startBtn.addEventListener('click', () => this.startGame());
                }

                if (resetBtn) {
                    resetBtn.addEventListener('click', () => this.resetGame());
                }

                if (modeBtn) {
                    modeBtn.addEventListener('click', () => this.toggleMode());
                }
            }

            toggleMode() {
                this.mode = this.mode === 'computer' ? 'human' : 'computer';
                const modeElement = document.getElementById('tictactoeMode');
                if (modeElement) {
                    modeElement.textContent = this.mode === 'computer' ? 'ÁîµËÑë' : 'Âèå‰∫∫';
                }
                this.showMessage(`Â∑≤ÂàáÊç¢Âà∞${this.mode === 'computer' ? 'ÁîµËÑëÂØπÊàò' : 'Âèå‰∫∫ÂØπÊàò'}Ê®°Âºè`, 'info');
            }

            startGame() {
                this.gameActive = true;
                this.currentPlayer = 'X';
                this.moves = 0;
                this.board = Array(3).fill(null).map(() => Array(3).fill(''));
                this.renderBoard();
                this.updateStats();
                this.showMessage('Ê∏∏ÊàèÂºÄÂßãÔºÅXÂÖàËµ∞', 'info');
            }

            resetGame() {
                this.gameActive = false;
                this.moves = 0;
                this.board = Array(3).fill(null).map(() => Array(3).fill(''));
                this.renderBoard();
                this.updateStats();
                this.showMessage('ÁÇπÂáª"ÂºÄÂßãÊ∏∏Êàè"ÂºÄÂßãÊåëÊàòÔºÅ', 'info');
            }

            makeMove(row, col) {
                if (!this.gameActive || this.board[row][col] !== '') return;
                if (this.isComputerTurn) return; // ÁîµËÑëÊÄùËÄÉÊó∂Á¶ÅÊ≠¢Áé©ÂÆ∂Êìç‰Ωú

                this.board[row][col] = this.currentPlayer;
                this.moves++;

                if (this.checkWin(this.currentPlayer)) {
                    this.gameWon();
                    return;
                }

                if (this.moves === 9) {
                    this.gameDraw();
                    return;
                }

                this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';
                this.renderBoard();
                this.updateStats();
                this.showMessage(`${this.currentPlayer}Ëµ∞Ê£ã`, 'info');

                // Â¶ÇÊûúÊòØÁîµËÑëÂõûÂêàÔºåÂª∂ËøüÂêéËÆ©ÁîµËÑëËµ∞Ê£ã
                if (this.currentPlayer === 'O') {
                    this.isComputerTurn = true;
                    setTimeout(() => this.computerMove(), this.computerDelay);
                }
            }

            computerMove() {
                if (!this.gameActive || this.currentPlayer !== 'O') return;

                // 1. Â∞ùËØïËé∑ËÉú
                let move = this.findWinningMove('O');
                if (move) {
                    this.makeComputerMove(move.row, move.col);
                    return;
                }

                // 2. ÈòªÊ≠¢Áé©ÂÆ∂Ëé∑ËÉú
                move = this.findWinningMove('X');
                if (move) {
                    this.makeComputerMove(move.row, move.col);
                    return;
                }

                // 3. ÈÄâÊã©ÊúÄ‰Ω≥‰ΩçÁΩÆ
                move = this.findBestMove();
                if (move) {
                    this.makeComputerMove(move.row, move.col);
                    return;
                }

                // 4. ÈöèÊú∫ÈÄâÊã©
                const availableMoves = [];
                for (let r = 0; r < 3; r++) {
                    for (let c = 0; c < 3; c++) {
                        if (this.board[r][c] === '') {
                            availableMoves.push({ row: r, col: c });
                        }
                    }
                }

                if (availableMoves.length > 0) {
                    const randomMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
                    this.makeComputerMove(randomMove.row, randomMove.col);
                }
            }

            makeComputerMove(row, col) {
                this.board[row][col] = this.currentPlayer;
                this.moves++;
                this.isComputerTurn = false;

                if (this.checkWin(this.currentPlayer)) {
                    this.gameWon();
                    return;
                }

                if (this.moves === 9) {
                    this.gameDraw();
                    return;
                }

                this.currentPlayer = 'X';
                this.renderBoard();
                this.updateStats();
                this.showMessage('XËµ∞Ê£ã', 'info');
            }

            findWinningMove(player) {
                for (let r = 0; r < 3; r++) {
                    for (let c = 0; c < 3; c++) {
                        if (this.board[r][c] === '') {
                            this.board[r][c] = player;
                            const wins = this.checkWin(player);
                            this.board[r][c] = '';
                            if (wins) {
                                return { row: r, col: c };
                            }
                        }
                    }
                }
                return null;
            }

            findBestMove() {
                // ‰ºòÂÖàÈÄâÊã©‰∏≠ÂøÉ
                if (this.board[1][1] === '') {
                    return { row: 1, col: 1 };
                }

                // ‰ºòÂÖàÈÄâÊã©ËßíËêΩ
                const corners = [
                    { row: 0, col: 0 },
                    { row: 0, col: 2 },
                    { row: 2, col: 0 },
                    { row: 2, col: 2 }
                ];

                const availableCorners = corners.filter(corner => this.board[corner.row][corner.col] === '');
                if (availableCorners.length > 0) {
                    return availableCorners[Math.floor(Math.random() * availableCorners.length)];
                }

                // ÈÄâÊã©Ëæπ
                const edges = [
                    { row: 0, col: 1 },
                    { row: 1, col: 0 },
                    { row: 1, col: 2 },
                    { row: 2, col: 1 }
                ];

                const availableEdges = edges.filter(edge => this.board[edge.row][edge.col] === '');
                if (availableEdges.length > 0) {
                    return availableEdges[Math.floor(Math.random() * availableEdges.length)];
                }

                return null;
            }

            checkWin(player) {
                // Ê£ÄÊü•Ë°å
                for (let i = 0; i < 3; i++) {
                    if (this.board[i][0] === player && this.board[i][1] === player && this.board[i][2] === player) {
                        return true;
                    }
                }

                // Ê£ÄÊü•Âàó
                for (let i = 0; i < 3; i++) {
                    if (this.board[0][i] === player && this.board[1][i] === player && this.board[2][i] === player) {
                        return true;
                    }
                }

                // Ê£ÄÊü•ÂØπËßíÁ∫ø
                if (this.board[0][0] === player && this.board[1][1] === player && this.board[2][2] === player) {
                    return true;
                }
                if (this.board[0][2] === player && this.board[1][1] === player && this.board[2][0] === player) {
                    return true;
                }

                return false;
            }

            gameWon() {
                this.gameActive = false;
                const winner = this.currentPlayer;
                
                const bestScore = this.getBestScore();
                const isNewRecord = !bestScore || this.moves < bestScore.moves;

                if (isNewRecord) {
                    this.saveBestScore();
                    this.showMessage(`üéâ ${winner}Ëé∑ËÉúÔºÅÊñ∞Á∫™ÂΩïÔºÅÊ≠•Êï∞Ôºö${this.moves}`, 'success');
                } else {
                    this.showMessage(`üéâ ${winner}Ëé∑ËÉúÔºÅÊ≠•Êï∞Ôºö${this.moves}`, 'success');
                }

                this.updateStats();
            }

            gameDraw() {
                this.gameActive = false;
                this.showMessage('ü§ù Âπ≥Â±ÄÔºÅ', 'info');
                this.updateStats();
            }

            renderBoard() {
                const board = document.getElementById('tictactoeBoard');
                if (!board) return;

                if (!this.gameActive && this.board.every(row => row.every(cell => cell === ''))) {
                    board.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 40px; color: var(--text-secondary);">ÁÇπÂáª"ÂºÄÂßãÊ∏∏Êàè"ÂºÄÂßãÊåëÊàò</div>';
                    return;
                }

                const fragment = document.createDocumentFragment();
                
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 3; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'tictactoe-cell';
                        cell.setAttribute('role', 'gridcell');
                        cell.setAttribute('aria-label', `‰ΩçÁΩÆ ${row},${col}`);
                        
                        if (this.board[row][col]) {
                            cell.textContent = this.board[row][col];
                            if (this.board[row][col] === 'X') {
                                cell.classList.add('player-x');
                            } else {
                                cell.classList.add('player-o');
                            }
                        }

                        if (this.gameActive && this.board[row][col] === '') {
                            cell.addEventListener('click', () => this.makeMove(row, col));
                        }

                        fragment.appendChild(cell);
                    }
                }

                board.innerHTML = '';
                board.appendChild(fragment);
            }

            updateStats() {
                const movesElement = document.getElementById('tictactoeMoves');
                const playerElement = document.getElementById('tictactoePlayer');
                const bestElement = document.getElementById('tictactoeBest');

                if (movesElement) movesElement.textContent = this.moves;
                if (playerElement) playerElement.textContent = this.currentPlayer;

                const bestScore = this.getBestScore();
                if (bestElement && bestScore) {
                    bestElement.textContent = `${bestScore.moves}Ê≠•`;
                } else if (bestElement) {
                    bestElement.textContent = '--';
                }
            }

            showMessage(text, type = 'info') {
                const messageElement = document.getElementById('tictactoeMessage');
                if (!messageElement) return;

                messageElement.textContent = text;
                messageElement.className = `game-message ${type}`;
            }

            getBestScore() {
                try {
                    const data = localStorage.getItem(this.storageKey);
                    return data ? JSON.parse(data) : null;
                } catch (error) {
                    console.warn('Failed to load tictactoe best score:', error);
                    return null;
                }
            }

            saveBestScore() {
                try {
                    const bestScore = {
                        moves: this.moves,
                        date: new Date().toISOString()
                    };
                    localStorage.setItem(this.storageKey, JSON.stringify(bestScore));
                } catch (error) {
                    console.warn('Failed to save tictactoe best score:', error);
                }
            }

            loadBestScore() {
                // Â∑≤Âú®getBestScore‰∏≠Â§ÑÁêÜ
            }

            destroy() {
                // Ê∏ÖÁêÜËµÑÊ∫ê
            }
        }

        // ==================== ‰∏ªÂ∫îÁî®Ê®°Âùó ====================
        class ClockApp {
            constructor() {
                this.selectedDate = new Date();
                this.currentMonth = new Date();
                this.clockInterval = null;
                this.isInitialized = false;
                this.memoryGame = null;
                this.snakeGame = null;
                this.sokobanGame = null;
                this.currentGame = 'memory';
                this.backgroundManager = new BackgroundManager();
                this.init();
            }

            init() {
                if (this.isInitialized) return;

                try {
                    // 1. Á´ãÂç≥Âä†ËΩΩÊ†∏ÂøÉÂäüËÉΩ
                    this.backgroundManager.loadSavedBackground();
                    this.backgroundManager.applyTheme(this.backgroundManager.currentTheme);
                    this.startClock();
                    
                    // 2. Âª∂ËøüÊâßË°åÈùûÊ†∏ÂøÉ‰ªªÂä°
                    setTimeout(() => {
                        this.setupEventListeners();
                        this.renderCalendar();
                        this.renderData();
                    }, 50);
                    
                    // 3. Âª∂ËøüÂàùÂßãÂåñÊ∏∏Êàè
                    setTimeout(() => {
                        this.lazyInitGames();
                    }, 300);
                    
                    // 4. Âª∂ËøüÊï∞ÊçÆÊ∏ÖÁêÜ
                    setTimeout(() => {
                        this.scheduleCleanup();
                    }, 1000);
                    
                    this.isInitialized = true;
                    console.log('Êó∂ÈíüÂ∫îÁî®ÂàùÂßãÂåñÂÆåÊàê');
                } catch (error) {
                    console.error('Â∫îÁî®ÂàùÂßãÂåñÂ§±Ë¥•:', error);
                    this.showError('Â∫îÁî®ÂàùÂßãÂåñÂ§±Ë¥•ÔºåËØ∑Âà∑Êñ∞È°µÈù¢ÈáçËØï');
                }
            }

            lazyInitGames() {
                if (!this.memoryGame) this.memoryGame = new MemoryGame();
                if (!this.snakeGame) this.snakeGame = new SnakeGame();
                if (!this.sokobanGame) this.sokobanGame = new SokobanGame();
                if (!this.chessGame) this.chessGame = new ChessGame();
                if (!this.gomokuGame) this.gomokuGame = new GomokuGame();
                if (!this.tetrisGame) this.tetrisGame = new TetrisGame();
                if (!this.minesweeperGame) this.minesweeperGame = new MinesweeperGame();
                if (!this.tictactoeGame) this.tictactoeGame = new TicTacToeGame();
                
                this.memoryGame.init();
                this.snakeGame.init();
                this.sokobanGame.init();
                this.chessGame.init();
                this.gomokuGame.init();
                this.tetrisGame.init();
                this.minesweeperGame.init();
                this.tictactoeGame.init();
            }

            setupEventListeners() {
                // ‰∏ªÈ¢òÂàáÊç¢
                document.getElementById('themeToggle').addEventListener('click', () => this.toggleTheme());

                // Êó•ÂéÜÂØºËà™
                document.getElementById('prevMonth').addEventListener('click', () => this.changeMonth(-1));
                document.getElementById('nextMonth').addEventListener('click', () => this.changeMonth(1));

                // ‰øùÂ≠òÊåâÈíÆ
                document.getElementById('saveNote').addEventListener('click', () => this.saveNote());
                document.getElementById('saveExpense').addEventListener('click', () => this.saveExpense());

            // Ê∏∏ÊàèÂàáÊç¢ÊåâÈíÆ
            document.getElementById('tabMemory').addEventListener('click', () => this.switchGame('memory'));
            document.getElementById('tabSnake').addEventListener('click', () => this.switchGame('snake'));
            document.getElementById('tabSokoban').addEventListener('click', () => this.switchGame('sokoban'));
            document.getElementById('tabChess').addEventListener('click', () => this.switchGame('chess'));
            document.getElementById('tabGomoku').addEventListener('click', () => this.switchGame('gomoku'));
            document.getElementById('tabTetris').addEventListener('click', () => this.switchGame('tetris'));
            document.getElementById('tabMinesweeper').addEventListener('click', () => this.switchGame('minesweeper'));
            document.getElementById('tabTicTacToe').addEventListener('click', () => this.switchGame('tictactoe'));

                // ËÉåÊôØÈÄâÊã©Âô®
                document.querySelectorAll('.bg-option').forEach(option => {
                    option.addEventListener('click', () => {
                        const theme = option.dataset.theme;
                        this.backgroundManager.currentTheme = theme;
                        this.backgroundManager.applyTheme(theme);
                        this.backgroundManager.saveBackground();
                    });
                });

                // Ëá™ÂÆö‰πâËÉåÊôØÁºñËæëÂô®
                this.setupCustomBgEditor();

                // ÈîÆÁõòÂø´Êç∑ÈîÆ
                document.getElementById('noteInput').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && e.ctrlKey) {
                        e.preventDefault();
                        this.saveNote();
                    }
                });

                document.getElementById('expenseAmount').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        document.getElementById('expenseDesc').focus();
                    }
                });

                document.getElementById('expenseDesc').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && e.ctrlKey) {
                        e.preventDefault();
                        this.saveExpense();
                    }
                });

                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        document.activeElement?.blur();
                    }
                });
            }

            setupCustomBgEditor() {
                const showBtn = document.getElementById('showCustomEditor');
                const toggleBtn = document.getElementById('toggleCustomEditor');
                const editor = document.getElementById('customBgEditor');
                const applyBtn = document.getElementById('applyCustomBg');
                const saveBtn = document.getElementById('saveCustomBg');
                const resetBtn = document.getElementById('resetCustomBg');
                const imageUpload = document.getElementById('bgImageUpload');

                if (showBtn) {
                    showBtn.addEventListener('click', () => {
                        editor.style.display = 'block';
                        showBtn.style.display = 'none';
                        this.loadCurrentColorsToEditor();
                    });
                }

                if (toggleBtn) {
                    toggleBtn.addEventListener('click', () => {
                        editor.style.display = 'none';
                        showBtn.style.display = 'block';
                    });
                }

                if (applyBtn) {
                    applyBtn.addEventListener('click', () => this.applyCustomColors());
                }

                if (saveBtn) {
                    saveBtn.addEventListener('click', () => this.saveCustomColors());
                }

                if (resetBtn) {
                    resetBtn.addEventListener('click', () => this.resetCustomColors());
                }

                // ÂõæÁâá‰∏ä‰º†Â§ÑÁêÜ
                if (imageUpload) {
                    imageUpload.addEventListener('change', (e) => this.handleImageUpload(e));
                }

                // ÂõæÁâáÊéßÂà∂ÊªëÂùó
                this.setupImageControls();

                // ÂêåÊ≠•È¢úËâ≤ËæìÂÖ•Ê°Ü
                this.setupColorSync();
            }

            setupImageControls() {
                const opacitySlider = document.getElementById('bgImageOpacity');
                const blurSlider = document.getElementById('bgImageBlur');
                const brightnessSlider = document.getElementById('bgImageBrightness');

                if (opacitySlider) {
                    opacitySlider.addEventListener('input', (e) => {
                        document.getElementById('bgImageOpacityValue').textContent = e.target.value;
                        this.updateImagePreview();
                    });
                }

                if (blurSlider) {
                    blurSlider.addEventListener('input', (e) => {
                        document.getElementById('bgImageBlurValue').textContent = e.target.value;
                        this.updateImagePreview();
                    });
                }

                if (brightnessSlider) {
                    brightnessSlider.addEventListener('input', (e) => {
                        document.getElementById('bgImageBrightnessValue').textContent = e.target.value;
                        this.updateImagePreview();
                    });
                }

                // ÂõæÁâáÊòæÁ§∫Ê®°Âºè
                document.querySelectorAll('input[name="bgImageMode"]').forEach(radio => {
                    radio.addEventListener('change', () => this.updateImagePreview());
                });
            }

            handleImageUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                if (!file.type.startsWith('image/')) {
                    this.showError('ËØ∑ÈÄâÊã©ÂõæÁâáÊñá‰ª∂');
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    this.currentImageData = e.target.result;
                    this.updateImagePreview();
                    this.showSuccess('ÂõæÁâáÂ∑≤Âä†ËΩΩ');
                };
                reader.onerror = () => {
                    this.showError('ÂõæÁâáÂä†ËΩΩÂ§±Ë¥•');
                };
                reader.readAsDataURL(file);
            }

            updateImagePreview() {
                const preview = document.getElementById('bgPreview');
                if (!preview || !this.currentImageData) return;

                const opacity = document.getElementById('bgImageOpacity')?.value || 50;
                const blur = document.getElementById('bgImageBlur')?.value || 0;
                const brightness = document.getElementById('bgImageBrightness')?.value || 100;
                const mode = document.querySelector('input[name="bgImageMode"]:checked')?.value || 'cover';

                const colors = this.getEditorColors();
                let backgroundStyle = `linear-gradient(135deg, ${colors.bgPrimary}, ${colors.bgSecondary})`;

                if (this.currentImageData) {
                    const imageStyle = `url(${this.currentImageData})`;
                    const imageFilter = `blur(${blur}px) brightness(${brightness}%)`;
                    const imageOpacity = opacity / 100;

                    switch(mode) {
                        case 'cover':
                            backgroundStyle = `${backgroundStyle}, ${imageStyle}`;
                            preview.style.backgroundSize = 'cover';
                            preview.style.backgroundPosition = 'center';
                            preview.style.backgroundRepeat = 'no-repeat';
                            break;
                        case 'contain':
                            backgroundStyle = `${backgroundStyle}, ${imageStyle}`;
                            preview.style.backgroundSize = 'contain';
                            preview.style.backgroundPosition = 'center';
                            preview.style.backgroundRepeat = 'no-repeat';
                            break;
                        case 'repeat':
                            backgroundStyle = `${backgroundStyle}, ${imageStyle}`;
                            preview.style.backgroundSize = 'auto';
                            preview.style.backgroundPosition = 'center';
                            preview.style.backgroundRepeat = 'repeat';
                            break;
                        case 'center':
                            backgroundStyle = `${backgroundStyle}, ${imageStyle}`;
                            preview.style.backgroundSize = 'auto';
                            preview.style.backgroundPosition = 'center';
                            preview.style.backgroundRepeat = 'no-repeat';
                            break;
                    }

                    preview.style.backgroundImage = backgroundStyle;
                    preview.style.filter = imageFilter;
                    preview.style.opacity = imageOpacity;
                } else {
                    preview.style.backgroundImage = backgroundStyle;
                    preview.style.filter = 'none';
                    preview.style.opacity = 1;
                    preview.style.backgroundSize = 'cover';
                    preview.style.backgroundPosition = 'center';
                    preview.style.backgroundRepeat = 'no-repeat';
                }

                preview.style.borderColor = colors.borderTraditional;
            }

            setupColorSync() {
                const colorInputs = [
                    { color: 'bgPrimaryColor', text: 'bgPrimaryText' },
                    { color: 'bgSecondaryColor', text: 'bgSecondaryText' },
                    { color: 'bgAccentColor', text: 'bgAccentText' },
                    { color: 'textPrimaryColor', text: 'textPrimaryText' },
                    { color: 'borderTraditionalColor', text: 'borderTraditionalText' },
                    { color: 'goldTraditionalColor', text: 'goldTraditionalText' }
                ];

                colorInputs.forEach(({ color, text }) => {
                    const colorInput = document.getElementById(color);
                    const textInput = document.getElementById(text);

                    if (colorInput && textInput) {
                        colorInput.addEventListener('input', () => {
                            textInput.value = colorInput.value;
                            this.updateBgPreview();
                        });

                        textInput.addEventListener('input', () => {
                            if (Utils.isValidColor(textInput.value)) {
                                colorInput.value = textInput.value;
                                this.updateBgPreview();
                            }
                        });
                    }
                });
            }

            loadCurrentColorsToEditor() {
                const colors = this.backgroundManager.getCurrentColors();
                
                const mappings = {
                    bgPrimaryColor: 'bgPrimary',
                    bgSecondaryColor: 'bgSecondary',
                    bgAccentColor: 'bgAccent',
                    textPrimaryColor: 'textPrimary',
                    borderTraditionalColor: 'borderTraditional',
                    goldTraditionalColor: 'goldTraditional'
                };

                Object.keys(mappings).forEach(colorId => {
                    const input = document.getElementById(colorId);
                    const textId = colorId.replace('Color', 'Text');
                    const textInput = document.getElementById(textId);
                    
                    if (input && textInput) {
                        const color = Utils.formatColor(colors[mappings[colorId]]);
                        input.value = color;
                        textInput.value = color;
                    }
                });

                this.updateBgPreview();
            }

            updateBgPreview() {
                const preview = document.getElementById('bgPreview');
                if (!preview) return;

                const colors = this.getEditorColors();
                preview.style.background = `linear-gradient(135deg, ${colors.bgPrimary}, ${colors.bgSecondary})`;
                preview.style.borderColor = colors.borderTraditional;
            }

            getEditorColors() {
                return {
                    bgPrimary: document.getElementById('bgPrimaryText')?.value || '#f5f5dc',
                    bgSecondary: document.getElementById('bgSecondaryText')?.value || '#e8e8d0',
                    bgAccent: document.getElementById('bgAccentText')?.value || '#d4d4b8',
                    textPrimary: document.getElementById('textPrimaryText')?.value || '#2c2c2c',
                    borderTraditional: document.getElementById('borderTraditionalText')?.value || '#8b4513',
                    goldTraditional: document.getElementById('goldTraditionalText')?.value || '#d4af37'
                };
            }

            applyCustomColors() {
                const colors = this.getEditorColors();
                this.backgroundManager.applyCustomColors(colors);
                this.backgroundManager.currentTheme = 'custom';
                this.updateBgPreview();
                this.showSuccess('Ëá™ÂÆö‰πâËÉåÊôØÂ∑≤Â∫îÁî®');
            }

            saveCustomColors() {
                const colors = this.getEditorColors();
                this.backgroundManager.applyCustomColors(colors);
                this.backgroundManager.currentTheme = 'custom';
                
                // ‰øùÂ≠òÂõæÁâáËÆæÁΩÆ
                const imageSettings = this.getImageSettings();
                if (this.currentImageData) {
                    imageSettings.data = this.currentImageData;
                }
                
                // ‰øùÂ≠òÂà∞localStorage
                try {
                    localStorage.setItem(CONFIG.STORAGE_KEYS.CUSTOM_BG, JSON.stringify({
                        colors: colors,
                        image: imageSettings
                    }));
                    this.showSuccess('Ëá™ÂÆö‰πâËÉåÊôØÂ∑≤‰øùÂ≠ò');
                } catch (error) {
                    console.error('‰øùÂ≠òÂ§±Ë¥•:', error);
                    this.showError('‰øùÂ≠òÂ§±Ë¥•');
                }
            }

            getImageSettings() {
                return {
                    opacity: document.getElementById('bgImageOpacity')?.value || 50,
                    blur: document.getElementById('bgImageBlur')?.value || 0,
                    brightness: document.getElementById('bgImageBrightness')?.value || 100,
                    mode: document.querySelector('input[name="bgImageMode"]:checked')?.value || 'cover'
                };
            }

            resetCustomColors() {
                this.backgroundManager.resetToDefault();
                this.loadCurrentColorsToEditor();
                this.showSuccess('Â∑≤ÈáçÁΩÆ‰∏∫ÈªòËÆ§ËÉåÊôØ');
            }

            toggleTheme() {
                const themes = ['xuanzhi', 'dark', 'blue', 'bamboo', 'plum'];
                const currentIndex = themes.indexOf(this.backgroundManager.currentTheme);
                const nextIndex = (currentIndex + 1) % themes.length;
                const nextTheme = themes[nextIndex];
                
                this.backgroundManager.currentTheme = nextTheme;
                this.backgroundManager.applyTheme(nextTheme);
                this.backgroundManager.saveBackground();
            }

            switchGame(gameType) {
                this.currentGame = gameType;
                
                const memoryContainer = document.getElementById('memoryGameContainer');
                const snakeContainer = document.getElementById('snakeGameContainer');
                const sokobanContainer = document.getElementById('sokobanGameContainer');
                const chessContainer = document.getElementById('chessGameContainer');
                const gomokuContainer = document.getElementById('gomokuGameContainer');
                const tetrisContainer = document.getElementById('tetrisGameContainer');
                const minesweeperContainer = document.getElementById('minesweeperGameContainer');
                const tictactoeContainer = document.getElementById('tictactoeGameContainer');
                const tabMemory = document.getElementById('tabMemory');
                const tabSnake = document.getElementById('tabSnake');
                const tabSokoban = document.getElementById('tabSokoban');
                const tabChess = document.getElementById('tabChess');
                const tabGomoku = document.getElementById('tabGomoku');
                const tabTetris = document.getElementById('tabTetris');
                const tabMinesweeper = document.getElementById('tabMinesweeper');
                const tabTicTacToe = document.getElementById('tabTicTacToe');

                [tabMemory, tabSnake, tabSokoban, tabChess, tabGomoku, tabTetris, tabMinesweeper, tabTicTacToe].forEach(btn => {
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-secondary');
                });

                [memoryContainer, snakeContainer, sokobanContainer, chessContainer, gomokuContainer, tetrisContainer, minesweeperContainer, tictactoeContainer].forEach(container => {
                    container.style.display = 'none';
                });

                if (gameType === 'memory') {
                    memoryContainer.style.display = 'flex';
                    tabMemory.classList.add('btn-primary');
                    tabMemory.classList.remove('btn-secondary');
                    this.snakeGame.stopTimer();
                    this.sokobanGame.isGameActive = false;
                } else if (gameType === 'snake') {
                    snakeContainer.style.display = 'flex';
                    tabSnake.classList.add('btn-primary');
                    tabSnake.classList.remove('btn-secondary');
                    this.memoryGame.stopTimer();
                    this.sokobanGame.isGameActive = false;
                } else if (gameType === 'sokoban') {
                    sokobanContainer.style.display = 'flex';
                    tabSokoban.classList.add('btn-primary');
                    tabSokoban.classList.remove('btn-secondary');
                    this.memoryGame.stopTimer();
                    this.snakeGame.stopTimer();
                } else if (gameType === 'chess') {
                    chessContainer.style.display = 'flex';
                    tabChess.classList.add('btn-primary');
                    tabChess.classList.remove('btn-secondary');
                    this.memoryGame.stopTimer();
                    this.snakeGame.stopTimer();
                    this.sokobanGame.isGameActive = false;
                } else if (gameType === 'gomoku') {
                    gomokuContainer.style.display = 'flex';
                    tabGomoku.classList.add('btn-primary');
                    tabGomoku.classList.remove('btn-secondary');
                    this.memoryGame.stopTimer();
                    this.snakeGame.stopTimer();
                    this.sokobanGame.isGameActive = false;
                } else if (gameType === 'tetris') {
                    tetrisContainer.style.display = 'flex';
                    tabTetris.classList.add('btn-primary');
                    tabTetris.classList.remove('btn-secondary');
                    this.memoryGame.stopTimer();
                    this.snakeGame.stopTimer();
                    this.sokobanGame.isGameActive = false;
                } else if (gameType === 'minesweeper') {
                    minesweeperContainer.style.display = 'flex';
                    tabMinesweeper.classList.add('btn-primary');
                    tabMinesweeper.classList.remove('btn-secondary');
                    this.memoryGame.stopTimer();
                    this.snakeGame.stopTimer();
                    this.sokobanGame.isGameActive = false;
                } else if (gameType === 'tictactoe') {
                    tictactoeContainer.style.display = 'flex';
                    tabTicTacToe.classList.add('btn-primary');
                    tabTicTacToe.classList.remove('btn-secondary');
                    this.memoryGame.stopTimer();
                    this.snakeGame.stopTimer();
                    this.sokobanGame.isGameActive = false;
                }
            }

            startClock() {
                const update = () => {
                    try {
                        const now = new Date();
                        const hours = String(now.getHours()).padStart(2, '0');
                        const minutes = String(now.getMinutes()).padStart(2, '0');
                        const seconds = String(now.getSeconds()).padStart(2, '0');
                        
                        const clockElement = document.getElementById('clock');
                        const dateElement = document.getElementById('dateDisplay');
                        
                        if (clockElement) {
                            clockElement.textContent = `${hours}:${minutes}:${seconds}`;
                        }
                        
                        if (dateElement) {
                            dateElement.textContent = now.toLocaleDateString('zh-CN', {
                                year: 'numeric', 
                                month: 'long', 
                                day: 'numeric', 
                                weekday: 'long'
                            });
                        }
                    } catch (error) {
                        console.error('Êó∂ÈíüÊõ¥Êñ∞Â§±Ë¥•:', error);
                    }
                };

                update();
                this.clockInterval = setInterval(update, CONFIG.UPDATE_INTERVAL);
            }

            stopClock() {
                if (this.clockInterval) {
                    clearInterval(this.clockInterval);
                    this.clockInterval = null;
                }
            }

            changeMonth(delta) {
                this.currentMonth.setMonth(this.currentMonth.getMonth() + delta);
                this.renderCalendar();
            }

            renderCalendar() {
                const year = this.currentMonth.getFullYear();
                const month = this.currentMonth.getMonth();
                
                const titleElement = document.getElementById('calendarTitle');
                if (titleElement) {
                    titleElement.textContent = `${year}Âπ¥${String(month + 1).padStart(2, '0')}Êúà`;
                }

                const firstDay = new Date(year, month, 1);
                const lastDay = new Date(year, month + 1, 0);
                const prevLastDay = new Date(year, month, 0).getDate();
                const startDay = firstDay.getDay();

                const notes = DataManager.getData(CONFIG.STORAGE_KEYS.NOTES, {});
                const expenses = DataManager.getData(CONFIG.STORAGE_KEYS.EXPENSES, {});
                const daysContainer = document.getElementById('calendarDays');
                
                if (!daysContainer) return;

                const fragment = document.createDocumentFragment();

                for (let i = startDay - 1; i >= 0; i--) {
                    const day = this.createDayElement(prevLastDay - i, true);
                    fragment.appendChild(day);
                }

                const today = new Date();
                for (let i = 1; i <= lastDay.getDate(); i++) {
                    const dateKey = Utils.formatDate(new Date(year, month, i));
                    const hasData = (notes[dateKey]?.length > 0) || (expenses[dateKey]?.length > 0);
                    const isToday = today.getFullYear() === year && today.getMonth() === month && today.getDate() === i;
                    const isSelected = this.selectedDate.getFullYear() === year && this.selectedDate.getMonth() === month && this.selectedDate.getDate() === i;
                    
                    const day = this.createDayElement(i, false, hasData, isToday, isSelected);
                    day.addEventListener('click', () => this.selectDate(year, month, i));
                    fragment.appendChild(day);
                }

                const totalCells = 42;
                const remainingCells = totalCells - (startDay + lastDay.getDate());
                for (let i = 1; i <= remainingCells; i++) {
                    const day = this.createDayElement(i, true);
                    fragment.appendChild(day);
                }

                daysContainer.innerHTML = '';
                daysContainer.appendChild(fragment);
            }

            createDayElement(day, isOtherMonth, hasData = false, isToday = false, isSelected = false) {
                const div = document.createElement('div');
                div.className = 'day';
                div.textContent = day;
                div.setAttribute('role', 'gridcell');
                div.setAttribute('tabindex', isOtherMonth ? '-1' : '0');
                
                if (isOtherMonth) {
                    div.classList.add('other-month');
                    div.setAttribute('aria-disabled', 'true');
                } else {
                    div.setAttribute('aria-label', `${day}Êó•`);
                    if (hasData) {
                        div.classList.add('has-data');
                        div.setAttribute('aria-label', `${day}Êó•ÔºåÊúâÊï∞ÊçÆ`);
                    }
                    if (isToday) {
                        div.classList.add('today');
                        div.setAttribute('aria-label', `${day}Êó•Ôºå‰ªäÂ§©`);
                    }
                    if (isSelected) {
                        div.classList.add('selected');
                        div.setAttribute('aria-selected', 'true');
                    }
                }

                return div;
            }

            selectDate(year, month, day) {
                this.selectedDate = new Date(year, month, day);
                this.renderCalendar();
                this.renderData();
            }

            renderData() {
                const dateKey = Utils.formatDate(this.selectedDate);
                const notes = DataManager.getItems(CONFIG.STORAGE_KEYS.NOTES, dateKey);
                const expenses = DataManager.getItems(CONFIG.STORAGE_KEYS.EXPENSES, dateKey);

                this.renderNotes(notes, dateKey);
                this.renderExpenses(expenses, dateKey);
                this.updateStats();
            }

            renderNotes(notes, dateKey) {
                const notesList = document.getElementById('notesList');
                if (!notesList) return;

                if (notes.length === 0) {
                    notesList.innerHTML = this.getEmptyStateHTML('ÊöÇÊó†ËÆ∞‰∫ã');
                    return;
                }

                const fragment = document.createDocumentFragment();
                notes.forEach(note => {
                    const item = this.createNoteElement(note, dateKey);
                    fragment.appendChild(item);
                });

                notesList.innerHTML = '';
                notesList.appendChild(fragment);
            }

            createNoteElement(note, dateKey) {
                const div = document.createElement('div');
                div.className = 'item';
                div.setAttribute('role', 'listitem');
                
                div.innerHTML = `
                    <div class="item-header">
                        <span class="item-date">${new Date(note.timestamp).toLocaleString('zh-CN')}</span>
                        <button class="item-delete" onclick="app.deleteNote('${dateKey}', '${note.id}')" 
                                aria-label="Âà†Èô§ËÆ∞‰∫ã" title="Âà†Èô§ËÆ∞‰∫ã">√ó</button>
                    </div>
                    <div class="item-content">${Utils.escapeHtml(note.text)}</div>
                `;

                return div;
            }

            renderExpenses(expenses, dateKey) {
                const expensesList = document.getElementById('expensesList');
                if (!expensesList) return;

                if (expenses.length === 0) {
                    expensesList.innerHTML = this.getEmptyStateHTML('ÊöÇÊó†Ê∂àË¥πËÆ∞ÂΩï');
                    return;
                }

                const fragment = document.createDocumentFragment();
                expenses.forEach(expense => {
                    const item = this.createExpenseElement(expense, dateKey);
                    fragment.appendChild(item);
                });

                expensesList.innerHTML = '';
                expensesList.appendChild(fragment);
            }

            createExpenseElement(expense, dateKey) {
                const div = document.createElement('div');
                div.className = 'item';
                div.setAttribute('role', 'listitem');
                
                div.innerHTML = `
                    <div class="item-header">
                        <span class="item-date">${new Date(expense.timestamp).toLocaleString('zh-CN')}</span>
                        <button class="item-delete" onclick="app.deleteExpense('${dateKey}', '${expense.id}')" 
                                aria-label="Âà†Èô§Ê∂àË¥πËÆ∞ÂΩï" title="Âà†Èô§Ê∂àË¥πËÆ∞ÂΩï">√ó</button>
                    </div>
                    <div class="expense-item">
                        <div class="item-content">${Utils.escapeHtml(expense.description)}</div>
                        <div class="expense-amount">${Utils.formatCurrency(expense.amount)}</div>
                    </div>
                `;

                return div;
            }

            getEmptyStateHTML(message) {
                return `
                    <div class="empty-state">
                        <div class="empty-state-icon">üì≠</div>
                        <div class="empty-state-text">${message}</div>
                    </div>
                `;
            }

            updateStats() {
                try {
                    const stats = DataManager.getStats(this.selectedDate);
                    
                    const todayElement = document.getElementById('todayExpense');
                    const monthElement = document.getElementById('monthExpense');
                    const avgElement = document.getElementById('avgExpense');

                    if (todayElement) todayElement.textContent = Utils.formatCurrency(stats.todayExpense);
                    if (monthElement) monthElement.textContent = Utils.formatCurrency(stats.monthExpense);
                    if (avgElement) avgElement.textContent = Utils.formatCurrency(stats.avgExpense);
                } catch (error) {
                    console.error('Êõ¥Êñ∞ÁªüËÆ°Â§±Ë¥•:', error);
                }
            }

            saveNote() {
                const input = document.getElementById('noteInput');
                if (!input) return;

                const text = input.value.trim();
                if (!text) {
                    this.showWarning('ËØ∑ËæìÂÖ•ËÆ∞‰∫ãÂÜÖÂÆπ');
                    return;
                }

                try {
                    const dateKey = Utils.formatDate(this.selectedDate);
                    DataManager.addItem(CONFIG.STORAGE_KEYS.NOTES, dateKey, {
                        id: Utils.generateId(),
                        text: text,
                        timestamp: Utils.getCurrentTimestamp()
                    });

                    input.value = '';
                    this.renderCalendar();
                    this.renderData();
                    this.showSuccess('ËÆ∞‰∫ãÂ∑≤‰øùÂ≠ò');
                } catch (error) {
                    console.error('‰øùÂ≠òËÆ∞‰∫ãÂ§±Ë¥•:', error);
                    this.showError('‰øùÂ≠òËÆ∞‰∫ãÂ§±Ë¥•');
                }
            }

            saveExpense() {
                const amountInput = document.getElementById('expenseAmount');
                const descInput = document.getElementById('expenseDesc');
                
                if (!amountInput || !descInput) return;

                const amount = amountInput.value.trim();
                const description = descInput.value.trim();

                if (!amount || isNaN(amount) || parseFloat(amount) <= 0) {
                    this.showWarning('ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑÈáëÈ¢ù');
                    amountInput.focus();
                    return;
                }

                try {
                    const dateKey = Utils.formatDate(this.selectedDate);
                    DataManager.addItem(CONFIG.STORAGE_KEYS.EXPENSES, dateKey, {
                        id: Utils.generateId(),
                        amount: parseFloat(amount),
                        description: description || 'Êú™ÂëΩÂêçÊ∂àË¥π',
                        timestamp: Utils.getCurrentTimestamp()
                    });

                    amountInput.value = '';
                    descInput.value = '';
                    this.renderCalendar();
                    this.renderData();
                    this.showSuccess('Ê∂àË¥πËÆ∞ÂΩïÂ∑≤‰øùÂ≠ò');
                } catch (error) {
                    console.error('‰øùÂ≠òÊ∂àË¥πÂ§±Ë¥•:', error);
                    this.showError('‰øùÂ≠òÊ∂àË¥πËÆ∞ÂΩïÂ§±Ë¥•');
                }
            }

            deleteNote(dateKey, id) {
                if (!confirm('Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊù°ËÆ∞‰∫ãÂêóÔºü')) return;

                try {
                    DataManager.deleteItem(CONFIG.STORAGE_KEYS.NOTES, dateKey, id);
                    this.renderCalendar();
                    this.renderData();
                    this.showSuccess('ËÆ∞‰∫ãÂ∑≤Âà†Èô§');
                } catch (error) {
                    console.error('Âà†Èô§ËÆ∞‰∫ãÂ§±Ë¥•:', error);
                    this.showError('Âà†Èô§ËÆ∞‰∫ãÂ§±Ë¥•');
                }
            }

            deleteExpense(dateKey, id) {
                if (!confirm('Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊù°Ê∂àË¥πËÆ∞ÂΩïÂêóÔºü')) return;

                try {
                    DataManager.deleteItem(CONFIG.STORAGE_KEYS.EXPENSES, dateKey, id);
                    this.renderCalendar();
                    this.renderData();
                    this.showSuccess('Ê∂àË¥πËÆ∞ÂΩïÂ∑≤Âà†Èô§');
                } catch (error) {
                    console.error('Âà†Èô§Ê∂àË¥πËÆ∞ÂΩïÂ§±Ë¥•:', error);
                    this.showError('Âà†Èô§Ê∂àË¥πËÆ∞ÂΩïÂ§±Ë¥•');
                }
            }

            scheduleCleanup() {
                setInterval(() => {
                    try {
                        DataManager.cleanupOldData();
                    } catch (error) {
                        console.warn('ÂÆöÊó∂Ê∏ÖÁêÜÂ§±Ë¥•:', error);
                    }
                }, 24 * 60 * 60 * 1000);
            }

            showSuccess(message) {
                console.log(`‚úÖ ${message}`);
            }

            showWarning(message) {
                alert(`‚ö†Ô∏è ${message}`);
            }

            showError(message) {
                alert(`‚ùå ${message}`);
            }

            destroy() {
                this.stopClock();
                this.isInitialized = false;
                console.log('Êó∂ÈíüÂ∫îÁî®Â∑≤ÈîÄÊØÅ');
            }
        }

        // ==================== Â∫îÁî®ÂêØÂä® ====================
        let app;

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                try {
                    app = new ClockApp();
                    window.app = app;
                } catch (error) {
                    console.error('Â∫îÁî®ÂêØÂä®Â§±Ë¥•:', error);
                    document.body.innerHTML = `
                        <div style="padding: 40px; text-align: center; font-family: sans-serif;">
                            <h1>‚ùå Â∫îÁî®Âä†ËΩΩÂ§±Ë¥•</h1>
                            <p>ËØ∑Âà∑Êñ∞È°µÈù¢ÈáçËØï</p>
                            <p style="color: #666; font-size: 14px;">${error.message}</p>
                        </div>
                    `;
                }
            });
        } else {
            try {
                app = new ClockApp();
                window.app = app;
            } catch (error) {
                console.error('Â∫îÁî®ÂêØÂä®Â§±Ë¥•:', error);
            }
        }

        export { app };
    </script>
</body>
</html>
