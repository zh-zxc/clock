<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ—¶é’Ÿ - è®°äº‹ä¸åŒæ­¥</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }
        body.light { background: #f0f0f0; color: #333; }
        
        .container { max-width: 1200px; margin: 0 auto; }
        
        /* é¡¶éƒ¨ */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
        }
        body.light .header { background: rgba(255,255,255,0.8); }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }
        .btn:hover { transform: translateY(-2px); }
        .btn-primary { background: #4cc9f0; color: white; }
        .btn-success { background: #00d084; color: white; }
        .btn-warning { background: #ffb84d; color: white; }
        .btn-danger { background: #ff4d4d; color: white; }
        .btn-secondary { background: #6c757d; color: white; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        
        /* æ—¶é’Ÿ */
        .clock-section {
            text-align: center;
            padding: 40px;
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            margin-bottom: 20px;
        }
        body.light .clock-section { background: rgba(255,255,255,0.8); }
        
        .clock {
            font-size: 3.5rem;
            font-weight: 800;
            font-family: 'Courier New', monospace;
            background: linear-gradient(to right, #4cc9f0, #f72585);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }
        
        .date-display { font-size: 1.3rem; opacity: 0.9; }
        
        .status {
            margin-top: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 14px;
        }
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ffb84d;
        }
        .status-dot.connected { background: #00d084; }
        .status-dot.error { background: #ff4d4d; }
        
        /* ä¸»å†…å®¹åŒº */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        @media (max-width: 968px) {
            .main-grid { grid-template-columns: 1fr; }
        }
        
        /* æ—¥å† */
        .calendar {
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 20px;
        }
        body.light .calendar { background: rgba(255,255,255,0.8); }
        
        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .calendar-title { font-size: 1.2rem; font-weight: 700; color: #4cc9f0; }
        body.light .calendar-title { color: #4361ee; }
        
        .calendar-nav button {
            padding: 6px 12px;
            background: rgba(255,255,255,0.2);
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-weight: 600;
        }
        body.light .calendar-nav button { background: rgba(0,0,0,0.1); color: #333; }
        
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
        }
        
        .day-header {
            text-align: center;
            font-weight: 700;
            font-size: 12px;
            padding: 8px 0;
            color: #4cc9f0;
        }
        
        .day {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-size: 14px;
            cursor: pointer;
            background: rgba(255,255,255,0.1);
            transition: all 0.3s;
            position: relative;
        }
        body.light .day { background: rgba(0,0,0,0.05); }
        .day:hover { background: rgba(76, 201, 240, 0.4); transform: scale(1.1); }
        .day.today { background: #f72585; color: white; font-weight: bold; }
        .day.selected { background: linear-gradient(135deg, #4cc9f0, #4361ee); color: white; }
        .day.has-data::after {
            content: "â€¢";
            position: absolute;
            bottom: 2px;
            right: 6px;
            color: #f72585;
            font-size: 16px;
        }
        .day.other-month { opacity: 0.3; }
        
        /* æ•°æ®åŒºåŸŸ */
        .data-section {
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 20px;
            max-height: 600px;
            overflow-y: auto;
        }
        body.light .data-section { background: rgba(255,255,255,0.8); }
        
        .section-title {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 15px;
            color: #4cc9f0;
        }
        body.light .section-title { color: #4361ee; }
        
        .input-group { margin-bottom: 15px; }
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            font-weight: 600;
        }
        .input-group input, .input-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-family: inherit;
            font-size: 14px;
        }
        body.light .input-group input, body.light .input-group textarea {
            background: rgba(255,255,255,0.9);
            color: #333;
            border-color: rgba(0,0,0,0.2);
        }
        
        .expense-inputs { display: flex; gap: 10px; }
        .expense-inputs input:first-child { flex: 0 0 30%; }
        .expense-inputs input:last-child { flex: 1; }
        
        .items-list {
            margin-top: 15px;
            max-height: 250px;
            overflow-y: auto;
            border-top: 1px solid rgba(255,255,255,0.1);
            padding-top: 10px;
        }
        
        .item {
            background: rgba(67, 97, 238, 0.2);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            animation: slideIn 0.3s ease;
        }
        body.light .item { background: rgba(67, 97, 238, 0.1); }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .item-date {
            font-size: 12px;
            font-weight: 600;
            color: #4cc9f0;
            opacity: 0.8;
        }
        
        .item-delete {
            background: #ff4d4d;
            border: none;
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
        }
        
        .item-content { font-size: 14px; line-height: 1.5; }
        
        .expense-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .expense-amount {
            font-weight: 700;
            color: #f72585;
            font-size: 1.1rem;
        }
        
        .stats-bar {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
            padding: 15px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
        }
        body.light .stats-bar { background: rgba(0,0,0,0.05); }
        
        .stat-item { text-align: center; }
        .stat-label { font-size: 12px; opacity: 0.7; margin-bottom: 5px; }
        .stat-value { font-size: 18px; font-weight: 700; color: #4cc9f0; }
        body.light .stat-value { color: #4361ee; }
        
        /* WebDAV */
        .webdav-config {
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }
        body.light .webdav-config { background: rgba(255,255,255,0.8); }
        
        .webdav-title {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 15px;
            color: #4cc9f0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .config-grid { display: grid; gap: 10px; }
        
        .connection-status {
            padding: 10px;
            border-radius: 8px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
        }
        .connection-status.disconnected {
            background: rgba(108, 117, 125, 0.2);
            color: #aaa;
            border: 1px solid #6c757d;
        }
        .connection-status.connected {
            background: rgba(0, 208, 132, 0.2);
            color: #00d084;
            border: 1px solid #00d084;
        }
        .connection-status.error {
            background: rgba(255, 77, 77, 0.2);
            color: #ff4d4d;
            border: 1px solid #ff4d4d;
        }
        
        .sync-controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        
        .sync-log {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 150px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        body.light .sync-log { background: rgba(0,0,0,0.1); }
        
        .log-entry { margin-bottom: 4px; opacity: 0.9; }
        .log-entry.success { color: #00d084; }
        .log-entry.error { color: #ff4d4d; }
        .log-entry.info { color: #4cc9f0; }
        .log-entry.warning { color: #ffb84d; }
        
        .tips {
            margin-top: 15px;
            padding: 12px;
            background: rgba(255, 184, 77, 0.1);
            border-left: 3px solid #ffb84d;
            border-radius: 6px;
            font-size: 12px;
            line-height: 1.6;
            color: #ffb84d;
        }
        
        /* å“åº”å¼ */
        @media (max-width: 480px) {
            .clock { font-size: 2.5rem; }
            .date-display { font-size: 1rem; }
            .header { flex-direction: column; gap: 10px; }
            .sync-controls { grid-template-columns: 1fr; }
            .stats-bar { grid-template-columns: 1fr; }
            .expense-inputs { flex-direction: column; }
            .expense-inputs input:first-child { flex: 1; }
        }
        
        /* æ»šåŠ¨æ¡ */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }
        
        /* åŠ è½½åŠ¨ç”» */
        .loading { opacity: 0.5; pointer-events: none; }
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="container">
        <!-- é¡¶éƒ¨ -->
        <div class="header">
            <div style="font-weight: 700; font-size: 1.2rem;">â° æ—¶é’Ÿåº”ç”¨</div>
            <div style="display: flex; gap: 10px;">
                <button class="btn btn-secondary" id="themeToggle">ğŸŒ“ ä¸»é¢˜</button>
                <button class="btn btn-primary" id="quickSync">ğŸ”„ åŒæ­¥</button>
            </div>
        </div>

        <!-- æ—¶é’Ÿ -->
        <div class="clock-section">
            <div class="clock" id="clock">00:00:00</div>
            <div class="date-display" id="dateDisplay">åŠ è½½ä¸­...</div>
            <div class="status">
                <span class="status-dot" id="statusDot"></span>
                <span id="statusText">æœªè¿æ¥</span>
            </div>
        </div>

        <!-- ä¸»å†…å®¹ -->
        <div class="main-grid">
            <!-- æ—¥å† -->
            <div class="calendar">
                <div class="calendar-header">
                    <div class="calendar-title" id="calendarTitle">YYYYå¹´MMæœˆ</div>
                    <div class="calendar-nav">
                        <button id="prevMonth"><</button>
                        <button id="nextMonth">></button>
                    </div>
                </div>
                <div class="calendar-grid">
                    <div class="day-header">æ—¥</div>
                    <div class="day-header">ä¸€</div>
                    <div class="day-header">äºŒ</div>
                    <div class="day-header">ä¸‰</div>
                    <div class="day-header">å››</div>
                    <div class="day-header">äº”</div>
                    <div class="day-header">å…­</div>
                </div>
                <div class="calendar-grid" id="calendarDays"></div>
            </div>

            <!-- æ•°æ® -->
            <div class="data-section">
                <!-- è®°äº‹ -->
                <div class="section-title">ğŸ“ è®°äº‹æœ¬</div>
                <div class="input-group">
                    <label>è®°äº‹å†…å®¹</label>
                    <textarea id="noteInput" placeholder="åœ¨æ­¤è¾“å…¥è®°äº‹å†…å®¹..."></textarea>
                </div>
                <button class="btn btn-primary" id="saveNote" style="width: 100%;">ä¿å­˜è®°äº‹</button>
                <div class="items-list" id="notesList"></div>

                <!-- æ¶ˆè´¹ -->
                <div class="section-title" style="margin-top: 25px;">ğŸ’° æ¶ˆè´¹è®°å½•</div>
                <div class="input-group">
                    <label>æ¶ˆè´¹ä¿¡æ¯</label>
                    <div class="expense-inputs">
                        <input type="number" id="expenseAmount" placeholder="é‡‘é¢" step="0.01" min="0">
                        <input type="text" id="expenseDesc" placeholder="æè¿°">
                    </div>
                </div>
                <button class="btn btn-primary" id="saveExpense" style="width: 100%;">è®°å½•æ¶ˆè´¹</button>
                <div class="items-list" id="expensesList"></div>

                <!-- ç»Ÿè®¡ -->
                <div class="stats-bar">
                    <div class="stat-item">
                        <div class="stat-label">æœ¬æ—¥æ¶ˆè´¹</div>
                        <div class="stat-value" id="todayExpense">Â¥0.00</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">æœ¬æœˆæ¶ˆè´¹</div>
                        <div class="stat-value" id="monthExpense">Â¥0.00</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">å¹³å‡æ¯æ—¥</div>
                        <div class="stat-value" id="avgExpense">Â¥0.00</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- WebDAV -->
        <div class="webdav-config">
            <div class="webdav-title">â˜ï¸ WebDAV äº‘ç›˜åŒæ­¥</div>
            
            <div class="config-grid">
                <div class="input-group">
                    <label>æœåŠ¡å™¨åœ°å€</label>
                    <input type="text" id="webdavUrl" value="https://rebun.infini-cloud.net/dav/" readonly>
                </div>
                
                <div class="input-group">
                    <label>ç”¨æˆ·åï¼ˆé‚®ç®±ï¼‰</label>
                    <input type="text" id="webdavUsername" placeholder="your-email@example.com">
                </div>
                
                <div class="input-group">
                    <label>åº”ç”¨å¯†ç </label>
                    <input type="password" id="webdavPassword" placeholder="è¯·è¾“å…¥åº”ç”¨å¯†ç ">
                </div>
                
                <div class="input-group">
                    <label>åŒæ­¥è·¯å¾„ï¼ˆå¯é€‰ï¼‰</label>
                    <input type="text" id="webdavPath" value="/clock-data/" placeholder="/clock-data/">
                </div>

                <div class="input-group">
                    <label>
                        <input type="checkbox" id="enableEncryption" checked>
                        å¯ç”¨æ•°æ®åŠ å¯†ï¼ˆAES-256ï¼‰
                    </label>
                </div>

                <div class="input-group">
                    <label>åŠ å¯†å¯†é’¥ï¼ˆå¯é€‰ï¼‰</label>
                    <input type="password" id="encryptionKey" placeholder="ç•™ç©ºä½¿ç”¨é»˜è®¤å¯†é’¥">
                </div>
            </div>

            <div class="tips">
                ğŸ’¡ <strong>ä½¿ç”¨è¯´æ˜ï¼š</strong><br>
                â€¢ éœ€è¦ä½¿ç”¨ Infini Cloud çš„<strong>åº”ç”¨å¯†ç </strong>ï¼ˆä¸æ˜¯ç™»å½•å¯†ç ï¼‰<br>
                â€¢ åœ¨ Infini Cloud è´¦æˆ·è®¾ç½®ä¸­ç”Ÿæˆåº”ç”¨å¯†ç <br>
                â€¢ é¦–æ¬¡ä½¿ç”¨è¯·å…ˆç‚¹å‡»"è¿æ¥ WebDAV"ï¼Œç„¶åç‚¹å‡»"ä¸Šä¼ æ•°æ®"
            </div>

            <div style="display: flex; gap: 10px; margin-top: 15px; flex-wrap: wrap;">
                <button class="btn btn-success" id="connectWebDAV">è¿æ¥ WebDAV</button>
                <button class="btn btn-danger" id="disconnectWebDAV" style="display: none;">æ–­å¼€è¿æ¥</button>
            </div>

            <div class="connection-status disconnected" id="connectionStatus">
                <span>â—</span>
                <span id="connectionStatusText">æœªè¿æ¥</span>
            </div>

            <div class="sync-controls">
                <button class="btn btn-primary" id="uploadData" disabled>ğŸ“¤ ä¸Šä¼ æ•°æ®</button>
                <button class="btn btn-warning" id="downloadData" disabled>ğŸ“¥ ä¸‹è½½æ•°æ®</button>
            </div>

            <div class="sync-log" id="syncLog"></div>
        </div>
    </div>

    <script>
        // é…ç½®
        const CONFIG = {
            STORAGE_KEYS: {
                NOTES: 'clock_notes',
                EXPENSES: 'clock_expenses',
                THEME: 'clock_theme',
                WEBDAV_CONFIG: 'webdav_config',
                SYNC_TIMESTAMP: 'sync_timestamp'
            },
            DEFAULT_ENCRYPTION_KEY: 'ClockAppDefaultKey2024!',
            WEBDAV_FILENAME: 'clock-data.json'
        };

        // å·¥å…·å‡½æ•°
        const Utils = {
            formatDate(date) {
                return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
            },
            generateId() {
                return Date.now() + Math.random().toString(36).substr(2, 9);
            },
            formatCurrency(amount) {
                return `Â¥${Number(amount).toFixed(2)}`;
            },
            getCurrentTimestamp() {
                return new Date().toISOString();
            },
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        };

        // æ•°æ®ç®¡ç†
        const DataManager = {
            getData(key, defaultValue = {}) {
                try {
                    const data = localStorage.getItem(key);
                    return data ? JSON.parse(data) : defaultValue;
                } catch {
                    return defaultValue;
                }
            },
            setData(key, data) {
                try {
                    localStorage.setItem(key, JSON.stringify(data));
                    return true;
                } catch {
                    return false;
                }
            },
            addItem(key, dateKey, item) {
                const data = this.getData(key, {});
                if (!data[dateKey]) data[dateKey] = [];
                data[dateKey].push(item);
                this.setData(key, data);
                return data;
            },
            deleteItem(key, dateKey, itemId) {
                const data = this.getData(key, {});
                if (data[dateKey]) {
                    data[dateKey] = data[dateKey].filter(item => item.id !== itemId);
                    if (data[dateKey].length === 0) delete data[dateKey];
                    this.setData(key, data);
                }
                return data;
            },
            getItems(key, dateKey) {
                const data = this.getData(key, {});
                return data[dateKey] || [];
            },
            getAllData() {
                return {
                    notes: this.getData(CONFIG.STORAGE_KEYS.NOTES, {}),
                    expenses: this.getData(CONFIG.STORAGE_KEYS.EXPENSES, {}),
                    version: '1.0',
                    exportTime: Utils.getCurrentTimestamp()
                };
            },
            importAllData(data) {
                try {
                    if (data.notes) this.setData(CONFIG.STORAGE_KEYS.NOTES, data.notes);
                    if (data.expenses) this.setData(CONFIG.STORAGE_KEYS.EXPENSES, data.expenses);
                    return true;
                } catch {
                    return false;
                }
            },
            clearAll() {
                try {
                    localStorage.removeItem(CONFIG.STORAGE_KEYS.NOTES);
                    localStorage.removeItem(CONFIG.STORAGE_KEYS.EXPENSES);
                    return true;
                } catch {
                    return false;
                }
            },
            getStats(selectedDate) {
                const expenses = this.getData(CONFIG.STORAGE_KEYS.EXPENSES, {});
                const dateKey = Utils.formatDate(selectedDate);
                const year = selectedDate.getFullYear();
                const month = selectedDate.getMonth();

                const todayExpense = expenses[dateKey]?.reduce((sum, e) => sum + e.amount, 0) || 0;
                let monthExpense = 0, expenseDays = 0;
                
                Object.keys(expenses).forEach(key => {
                    const d = new Date(key);
                    if (d.getFullYear() === year && d.getMonth() === month) {
                        monthExpense += expenses[key].reduce((sum, e) => sum + e.amount, 0);
                        expenseDays++;
                    }
                });

                const avgExpense = expenseDays > 0 ? monthExpense / expenseDays : 0;
                return { todayExpense, monthExpense, avgExpense };
            }
        };

        // åŠ å¯†ç®¡ç†
        class EncryptionManager {
            constructor() {
                this.key = null;
                this.algorithm = { name: 'AES-GCM', length: 256 };
            }

            async initialize(password) {
                try {
                    const encoder = new TextEncoder();
                    const passwordBuffer = encoder.encode(password);
                    const keyMaterial = await crypto.subtle.importKey('raw', passwordBuffer, { name: 'PBKDF2' }, false, ['deriveBits', 'deriveKey']);
                    const key = await crypto.subtle.deriveKey({ name: 'PBKDF2', salt: encoder.encode('ClockAppSalt2024'), iterations: 100000, hash: 'SHA-256' }, keyMaterial, this.algorithm, false, ['encrypt', 'decrypt']);
                    this.key = key;
                    return true;
                } catch {
                    return false;
                }
            }

            async encrypt(data) {
                if (!this.key) throw new Error('åŠ å¯†å¯†é’¥æœªåˆå§‹åŒ–');
                const encoder = new TextEncoder();
                const dataBuffer = encoder.encode(JSON.stringify(data));
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const encryptedBuffer = await crypto.subtle.encrypt({ name: 'AES-GCM', iv: iv }, this.key, dataBuffer);
                const combined = new Uint8Array(iv.length + encryptedBuffer.byteLength);
                combined.set(iv);
                combined.set(new Uint8Array(encryptedBuffer), iv.length);
                return btoa(String.fromCharCode(...combined));
            }

            async decrypt(encryptedData) {
                if (!this.key) throw new Error('åŠ å¯†å¯†é’¥æœªåˆå§‹åŒ–');
                try {
                    const combined = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));
                    const iv = combined.slice(0, 12);
                    const data = combined.slice(12);
                    const decryptedBuffer = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: iv }, this.key, data);
                    const decoder = new TextDecoder();
                    return JSON.parse(decoder.decode(decryptedBuffer));
                } catch {
                    throw new Error('è§£å¯†å¤±è´¥');
                }
            }

            async isEncrypted(data) {
                try {
                    const decoded = atob(data);
                    return decoded.length > 12;
                } catch {
                    return false;
                }
            }
        }

        // WebDAVç®¡ç†
        class WebDAVManager {
            constructor() {
                this.config = null;
                this.isConnected = false;
            }

            async connect(config) {
                this.config = config;
                try {
                    const response = await fetch(this.config.url, {
                        method: 'PROPFIND',
                        headers: {
                            'Depth': '1',
                            'Authorization': `Basic ${btoa(`${this.config.username}:${this.config.password}`)}`
                        }
                    });
                    if (response.ok || response.status === 207) {
                        this.isConnected = true;
                        return { success: true, message: 'è¿æ¥æˆåŠŸ' };
                    }
                    throw new Error(`è¿æ¥å¤±è´¥: ${response.status}`);
                } catch (error) {
                    this.isConnected = false;
                    return { success: false, message: error.message };
                }
            }

            async disconnect() {
                this.config = null;
                this.isConnected = false;
                return { success: true, message: 'å·²æ–­å¼€è¿æ¥' };
            }

            async upload(data, filename = CONFIG.WEBDAV_FILENAME) {
                if (!this.isConnected || !this.config) {
                    return { success: false, message: 'æœªè¿æ¥åˆ°WebDAVæœåŠ¡å™¨' };
                }
                try {
                    const path = this.normalizePath(filename);
                    const url = `${this.config.url}${path}`;
                    const content = JSON.stringify(data, null, 2);
                    const response = await fetch(url, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Basic ${btoa(`${this.config.username}:${this.config.password}`)}`
                        },
                        body: content
                    });
                    if (response.ok) {
                        return { success: true, message: 'ä¸Šä¼ æˆåŠŸ' };
                    }
                    const errorText = await response.text();
                    throw new Error(`ä¸Šä¼ å¤±è´¥: ${response.status}. ${errorText.substring(0, 100)}`);
                } catch (error) {
                    return { success: false, message: error.message };
                }
            }

            async download(filename = CONFIG.WEBDAV_FILENAME) {
                if (!this.isConnected || !this.config) {
                    return { success: false, message: 'æœªè¿æ¥åˆ°WebDAVæœåŠ¡å™¨' };
                }
                try {
                    const path = this.normalizePath(filename);
                    const url = `${this.config.url}${path}`;
                    const response = await fetch(url, {
                        headers: {
                            'Authorization': `Basic ${btoa(`${this.config.username}:${this.config.password}`)}`
                        }
                    });
                    if (response.ok) {
                        const text = await response.text();
                        try {
                            const data = JSON.parse(text);
                            return { success: true, data: data };
                        } catch {
                            throw new Error('æœåŠ¡å™¨è¿”å›äº†æ— æ•ˆçš„æ•°æ®æ ¼å¼');
                        }
                    } else if (response.status === 404) {
                        return { success: false, message: 'æ–‡ä»¶ä¸å­˜åœ¨', notFound: true };
                    }
                    throw new Error(`ä¸‹è½½å¤±è´¥: ${response.status}`);
                } catch (error) {
                    return { success: false, message: error.message };
                }
            }

            normalizePath(filename) {
                let path = this.config.path || '/';
                if (!path.startsWith('/')) path = '/' + path;
                if (!path.endsWith('/')) path = path + '/';
                return path + filename;
            }
        }

        // åŒæ­¥ç®¡ç†
        class SyncManager {
            constructor(dataManager, webDAVManager, encryptionManager) {
                this.dataManager = dataManager;
                this.webDAVManager = webDAVManager;
                this.encryptionManager = encryptionManager;
                this.isSyncing = false;
                this.syncLog = [];
            }

            async sync(direction = 'auto') {
                if (this.isSyncing) return { success: false, message: 'åŒæ­¥æ­£åœ¨è¿›è¡Œä¸­' };
                this.isSyncing = true;
                this.addLog('å¼€å§‹åŒæ­¥...', 'info');

                try {
                    if (!this.webDAVManager.isConnected) {
                        this.addLog('æœªè¿æ¥åˆ°WebDAVæœåŠ¡å™¨', 'error');
                        return { success: false, message: 'æœªè¿æ¥åˆ°WebDAVæœåŠ¡å™¨' };
                    }

                    const localData = this.getLocalData();
                    this.addLog(`æœ¬åœ°æ•°æ®: ${Object.keys(localData.notes).length}æ¡è®°äº‹, ${Object.keys(localData.expenses).length}æ¡æ¶ˆè´¹`, 'info');

                    const downloadResult = await this.webDAVManager.download();
                    
                    if (!downloadResult.success) {
                        if (downloadResult.notFound) {
                            this.addLog('äº‘ç«¯æ–‡ä»¶ä¸å­˜åœ¨ï¼Œå°†ä¸Šä¼ æœ¬åœ°æ•°æ®', 'info');
                            return await this.uploadData(localData);
                        }
                        this.addLog(`ä¸‹è½½å¤±è´¥: ${downloadResult.message}`, 'error');
                        return { success: false, message: `ä¸‹è½½å¤±è´¥: ${downloadResult.message}` };
                    }

                    const cloudData = downloadResult.data;
                    this.addLog(`äº‘ç«¯æ•°æ®: ${Object.keys(cloudData.notes).length}æ¡è®°äº‹, ${Object.keys(cloudData.expenses).length}æ¡æ¶ˆè´¹`, 'info');

                    if (direction === 'auto') {
                        const localTime = new Date(localStorage.getItem(CONFIG.SYNC_TIMESTAMP) || 0);
                        const cloudTime = new Date(cloudData.lastModified || 0);
                        if (localTime > cloudTime) {
                            this.addLog('æœ¬åœ°æ•°æ®è¾ƒæ–°ï¼Œä¸Šä¼ åˆ°äº‘ç«¯', 'info');
                            return await this.uploadData(localData);
                        } else {
                            this.addLog('äº‘ç«¯æ•°æ®è¾ƒæ–°ï¼Œä¸‹è½½åˆ°æœ¬åœ°', 'info');
                            this.saveLocalData(cloudData);
                            return { success: true, message: 'ä¸‹è½½æˆåŠŸ' };
                        }
                    } else if (direction === 'upload') {
                        return await this.uploadData(localData);
                    } else if (direction === 'download') {
                        this.saveLocalData(cloudData);
                        return { success: true, message: 'ä¸‹è½½æˆåŠŸ' };
                    }
                } catch (error) {
                    this.addLog(`åŒæ­¥å¼‚å¸¸: ${error.message}`, 'error');
                    return { success: false, message: `åŒæ­¥å¼‚å¸¸: ${error.message}` };
                } finally {
                    this.isSyncing = false;
                }
            }

            async uploadData(data) {
                try {
                    const enableEncryption = document.getElementById('enableEncryption').checked;
                    let uploadData = data;
                    if (enableEncryption) {
                        const encryptionKey = document.getElementById('encryptionKey').value || CONFIG.DEFAULT_ENCRYPTION_KEY;
                        if (!this.encryptionManager.key) {
                            await this.encryptionManager.initialize(encryptionKey);
                        }
                        uploadData = await this.encryptionManager.encrypt(data);
                        this.addLog('æ•°æ®åŠ å¯†å®Œæˆ', 'success');
                    }
                    const result = await this.webDAVManager.upload(uploadData);
                    if (result.success) {
                        localStorage.setItem(CONFIG.SYNC_TIMESTAMP, Utils.getCurrentTimestamp());
                        this.addLog('ä¸Šä¼ æˆåŠŸ', 'success');
                    } else {
                        this.addLog(`ä¸Šä¼ å¤±è´¥: ${result.message}`, 'error');
                    }
                    return result;
                } catch (error) {
                    this.addLog(`ä¸Šä¼ å¼‚å¸¸: ${error.message}`, 'error');
                    return { success: false, message: error.message };
                }
            }

            getLocalData() {
                return this.dataManager.getAllData();
            }

            saveLocalData(data) {
                this.dataManager.importAllData(data);
                localStorage.setItem(CONFIG.SYNC_TIMESTAMP, Utils.getCurrentTimestamp());
            }

            addLog(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                this.syncLog.push({ timestamp, message, type });
                if (this.syncLog.length > 50) this.syncLog.shift();
                this.updateLogUI();
            }

            updateLogUI() {
                const logContainer = document.getElementById('syncLog');
                if (!logContainer) return;
                const logHTML = this.syncLog.map(log => `<div class="log-entry ${log.type}">[${log.timestamp}] ${log.message}</div>`).join('');
                logContainer.innerHTML = logHTML;
                logContainer.scrollTop = logContainer.scrollHeight;
            }
        }

        // åº”ç”¨ä¸»ç±»
        class ClockApp {
            constructor() {
                this.selectedDate = new Date();
                this.currentMonth = new Date();
                this.encryptionManager = new EncryptionManager();
                this.webDAVManager = new WebDAVManager();
                this.syncManager = new SyncManager(DataManager, this.webDAVManager, this.encryptionManager);
                this.isDarkTheme = true;
                this.init();
            }

            init() {
                this.loadTheme();
                this.loadWebDAVConfig();
                this.setupEventListeners();
                this.startClock();
                this.renderCalendar();
                this.renderData();
            }

            loadTheme() {
                const savedTheme = localStorage.getItem(CONFIG.STORAGE_KEYS.THEME);
                if (savedTheme) this.isDarkTheme = savedTheme === 'dark';
                this.applyTheme();
            }

            applyTheme() {
                document.body.className = this.isDarkTheme ? '' : 'light';
            }

            loadWebDAVConfig() {
                const savedConfig = localStorage.getItem(CONFIG.STORAGE_KEYS.WEBDAV_CONFIG);
                if (savedConfig) {
                    const config = JSON.parse(savedConfig);
                    document.getElementById('webdavUsername').value = config.username || '';
                    document.getElementById('webdavPassword').value = config.password || '';
                    document.getElementById('webdavPath').value = config.path || '/clock-data/';
                    document.getElementById('enableEncryption').checked = config.enableEncryption !== false;
                    document.getElementById('encryptionKey').value = config.encryptionKey || '';
                }
            }

            saveWebDAVConfig() {
                const config = {
                    url: document.getElementById('webdavUrl').value,
                    username: document.getElementById('webdavUsername').value,
                    password: document.getElementById('webdavPassword').value,
                    path: document.getElementById('webdavPath').value,
                    enableEncryption: document.getElementById('enableEncryption').checked,
                    encryptionKey: document.getElementById('encryptionKey').value
                };
                localStorage.setItem(CONFIG.STORAGE_KEYS.WEBDAV_CONFIG, JSON.stringify(config));
            }

            setupEventListeners() {
                document.getElementById('themeToggle').addEventListener('click', () => {
                    this.isDarkTheme = !this.isDarkTheme;
                    localStorage.setItem(CONFIG.STORAGE_KEYS.THEME, this.isDarkTheme ? 'dark' : 'light');
                    this.applyTheme();
                });

                document.getElementById('prevMonth').addEventListener('click', () => {
                    this.currentMonth.setMonth(this.currentMonth.getMonth() - 1);
                    this.renderCalendar();
                });

                document.getElementById('nextMonth').addEventListener('click', () => {
                    this.currentMonth.setMonth(this.currentMonth.getMonth() + 1);
                    this.renderCalendar();
                });

                document.getElementById('saveNote').addEventListener('click', () => this.saveNote());
                document.getElementById('saveExpense').addEventListener('click', () => this.saveExpense());

                document.getElementById('connectWebDAV').addEventListener('click', () => this.connectWebDAV());
                document.getElementById('disconnectWebDAV').addEventListener('click', () => this.disconnectWebDAV());
                document.getElementById('uploadData').addEventListener('click', () => this.uploadData());
                document.getElementById('downloadData').addEventListener('click', () => this.downloadData());
                document.getElementById('quickSync').addEventListener('click', () => this.quickSync());

                document.getElementById('noteInput').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && e.ctrlKey) {
                        e.preventDefault();
                        this.saveNote();
                    }
                });

                document.getElementById('expenseAmount').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        document.getElementById('expenseDesc').focus();
                    }
                });

                document.getElementById('expenseDesc').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && e.ctrlKey) {
                        e.preventDefault();
                        this.saveExpense();
                    }
                });
            }

            startClock() {
                const update = () => {
                    const now = new Date();
                    const hours = String(now.getHours()).padStart(2, '0');
                    const minutes = String(now.getMinutes()).padStart(2, '0');
                    const seconds = String(now.getSeconds()).padStart(2, '0');
                    document.getElementById('clock').textContent = `${hours}:${minutes}:${seconds}`;
                    document.getElementById('dateDisplay').textContent = now.toLocaleDateString('zh-CN', {
                        year: 'numeric', month: 'long', day: 'numeric', weekday: 'long'
                    });
                };
                update();
                setInterval(update, 1000);
            }

            renderCalendar() {
                const year = this.currentMonth.getFullYear();
                const month = this.currentMonth.getMonth();
                document.getElementById('calendarTitle').textContent = `${year}å¹´${String(month + 1).padStart(2, '0')}æœˆ`;

                const firstDay = new Date(year, month, 1);
                const lastDay = new Date(year, month + 1, 0);
                const prevLastDay = new Date(year, month, 0).getDate();
                const startDay = firstDay.getDay();

                const notes = DataManager.getData(CONFIG.STORAGE_KEYS.NOTES, {});
                const expenses = DataManager.getData(CONFIG.STORAGE_KEYS.EXPENSES, {});
                const daysContainer = document.getElementById('calendarDays');
                daysContainer.innerHTML = '';

                for (let i = startDay - 1; i >= 0; i--) {
                    const day = this.createDayElement(prevLastDay - i, true);
                    daysContainer.appendChild(day);
                }

                const today = new Date();
                for (let i = 1; i <= lastDay.getDate(); i++) {
                    const dateKey = Utils.formatDate(new Date(year, month, i));
                    const hasData = (notes[dateKey]?.length > 0) || (expenses[dateKey]?.length > 0);
                    const isToday = today.getFullYear() === year && today.getMonth() === month && today.getDate() === i;
                    const isSelected = this.selectedDate.getFullYear() === year && this.selectedDate.getMonth() === month && this.selectedDate.getDate() === i;
                    const day = this.createDayElement(i, false, hasData, isToday, isSelected);
                    day.addEventListener('click', () => {
                        this.selectedDate = new Date(year, month, i);
                        this.renderCalendar();
                        this.renderData();
                    });
                    daysContainer.appendChild(day);
                }

                const totalCells = 42;
                const remainingCells = totalCells - (startDay + lastDay.getDate());
                for (let i = 1; i <= remainingCells; i++) {
                    const day = this.createDayElement(i, true);
                    daysContainer.appendChild(day);
                }
            }

            createDayElement(day, isOtherMonth, hasData = false, isToday = false, isSelected = false) {
                const div = document.createElement('div');
                div.className = 'day';
                div.textContent = day;
                if (isOtherMonth) div.classList.add('other-month');
                if (hasData) div.classList.add('has-data');
                if (isToday) div.classList.add('today');
                if (isSelected) div.classList.add('selected');
                return div;
            }

            renderData() {
                const dateKey = Utils.formatDate(this.selectedDate);
                const notes = DataManager.getItems(CONFIG.STORAGE_KEYS.NOTES, dateKey);
                const expenses = DataManager.getItems(CONFIG.STORAGE_KEYS.EXPENSES, dateKey);

                document.getElementById('notesList').innerHTML = notes.map(note => `
                    <div class="item">
                        <div class="item-header">
                            <span class="item-date">${new Date(note.timestamp).toLocaleString('zh-CN')}</span>
                            <button class="item-delete" onclick="app.deleteNote('${dateKey}', '${note.id}')">Ã—</button>
                        </div>
                        <div class="item-content">${Utils.escapeHtml(note.text)}</div>
                    </div>
                `).join('');

                document.getElementById('expensesList').innerHTML = expenses.map(expense => `
                    <div class="item">
                        <div class="item-header">
                            <span class="item-date">${new Date(expense.timestamp).toLocaleString('zh-CN')}</span>
                            <button class="item-delete" onclick="app.deleteExpense('${dateKey}', '${expense.id}')">Ã—</button>
                        </div>
                        <div class="expense-item">
                            <div class="item-content">${Utils.escapeHtml(expense.description)}</div>
                            <div class="expense-amount">${Utils.formatCurrency(expense.amount)}</div>
                        </div>
                    </div>
                `).join('');

                this.updateStats();
            }

            updateStats() {
                const stats = DataManager.getStats(this.selectedDate);
                document.getElementById('todayExpense').textContent = Utils.formatCurrency(stats.todayExpense);
                document.getElementById('monthExpense').textContent = Utils.formatCurrency(stats.monthExpense);
                document.getElementById('avgExpense').textContent = Utils.formatCurrency(stats.avgExpense);
            }

            saveNote() {
                const text = document.getElementById('noteInput').value.trim();
                if (!text) {
                    alert('è¯·è¾“å…¥è®°äº‹å†…å®¹');
                    return;
                }
                const dateKey = Utils.formatDate(this.selectedDate);
                DataManager.addItem(CONFIG.STORAGE_KEYS.NOTES, dateKey, {
                    id: Utils.generateId(),
                    text: text,
                    timestamp: Utils.getCurrentTimestamp()
                });
                document.getElementById('noteInput').value = '';
                this.renderCalendar();
                this.renderData();
            }

            saveExpense() {
                const amount = document.getElementById('expenseAmount').value.trim();
                const description = document.getElementById('expenseDesc').value.trim();
                if (!amount || isNaN(amount) || parseFloat(amount) <= 0) {
                    alert('è¯·è¾“å…¥æœ‰æ•ˆçš„é‡‘é¢');
                    return;
                }
                const dateKey = Utils.formatDate(this.selectedDate);
                DataManager.addItem(CONFIG.STORAGE_KEYS.EXPENSES, dateKey, {
                    id: Utils.generateId(),
                    amount: parseFloat(amount),
                    description: description || 'æœªå‘½åæ¶ˆè´¹',
                    timestamp: Utils.getCurrentTimestamp()
                });
                document.getElementById('expenseAmount').value = '';
                document.getElementById('expenseDesc').value = '';
                this.renderCalendar();
                this.renderData();
            }

            deleteNote(dateKey, id) {
                if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡è®°äº‹å—ï¼Ÿ')) {
                    DataManager.deleteItem(CONFIG.STORAGE_KEYS.NOTES, dateKey, id);
                    this.renderCalendar();
                    this.renderData();
                }
            }

            deleteExpense(dateKey, id) {
                if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡æ¶ˆè´¹è®°å½•å—ï¼Ÿ')) {
                    DataManager.deleteItem(CONFIG.STORAGE_KEYS.EXPENSES, dateKey, id);
                    this.renderCalendar();
                    this.renderData();
                }
            }

            async connectWebDAV() {
                const url = document.getElementById('webdavUrl').value.trim();
                const username = document.getElementById('webdavUsername').value.trim();
                const password = document.getElementById('webdavPassword').value.trim();
                const path = document.getElementById('webdavPath').value.trim() || '/clock-data/';

                if (!url || !username || !password) {
                    alert('è¯·å¡«å†™å®Œæ•´çš„WebDAVé…ç½®ä¿¡æ¯');
                    return;
                }

                this.setConnectionStatus('connecting', 'è¿æ¥ä¸­...');
                document.getElementById('connectWebDAV').disabled = true;

                try {
                    const config = { url, username, password, path };
                    const result = await this.webDAVManager.connect(config);

                    if (result.success) {
                        this.setConnectionStatus('connected', 'å·²è¿æ¥');
                        document.getElementById('connectWebDAV').style.display = 'none';
                        document.getElementById('disconnectWebDAV').style.display = 'inline-block';
                        document.getElementById('uploadData').disabled = false;
                        document.getElementById('downloadData').disabled = false;
                        this.saveWebDAVConfig();
                        this.syncManager.addLog('WebDAVè¿æ¥æˆåŠŸ', 'success');
                        this.updateSyncStatus('connected', 'å·²è¿æ¥');
                    } else {
                        this.setConnectionStatus('error', `è¿æ¥å¤±è´¥: ${result.message}`);
                        this.syncManager.addLog(`è¿æ¥å¤±è´¥: ${result.message}`, 'error');
                        this.updateSyncStatus('error', 'è¿æ¥å¤±è´¥');
                    }
                } catch (error) {
                    this.setConnectionStatus('error', `è¿æ¥å¼‚å¸¸: ${error.message}`);
                    this.syncManager.addLog(`è¿æ¥å¼‚å¸¸: ${error.message}`, 'error');
                    this.updateSyncStatus('error', 'è¿æ¥å¼‚å¸¸');
                } finally {
                    document.getElementById('connectWebDAV').disabled = false;
                }
            }

            async disconnectWebDAV() {
                await this.webDAVManager.disconnect();
                this.setConnectionStatus('disconnected', 'æœªè¿æ¥');
                document.getElementById('connectWebDAV').style.display = 'inline-block';
                document.getElementById('disconnectWebDAV').style.display = 'none';
                document.getElementById('uploadData').disabled = true;
                document.getElementById('downloadData').disabled = true;
                this.updateSyncStatus('disconnected', 'æœªè¿æ¥');
                this.syncManager.addLog('å·²æ–­å¼€WebDAVè¿æ¥', 'info');
            }

            async uploadData() {
                this.setLoading('uploadData', true);
                const result = await this.syncManager.sync('upload');
                this.setLoading('uploadData', false);

                if (result.success) {
                    this.updateSyncStatus('connected', 'ä¸Šä¼ æˆåŠŸ');
                    alert('æ•°æ®ä¸Šä¼ æˆåŠŸï¼');
                } else {
                    this.updateSyncStatus('error', 'ä¸Šä¼ å¤±è´¥');
                    alert(`ä¸Šä¼ å¤±è´¥: ${result.message}`);
                }
            }

            async downloadData() {
                this.setLoading('downloadData', true);
                const result = await this.syncManager.sync('download');
                this.setLoading('downloadData', false);

                if (result.success) {
                    this.updateSyncStatus('connected', 'ä¸‹è½½æˆåŠŸ');
                    this.renderCalendar();
                    this.renderData();
                    alert('æ•°æ®ä¸‹è½½æˆåŠŸï¼');
                } else {
                    this.updateSyncStatus('error', 'ä¸‹è½½å¤±è´¥');
                    alert(`ä¸‹è½½å¤±è´¥: ${result.message}`);
                }
            }

            async quickSync() {
                if (!this.webDAVManager.isConnected) {
                    alert('è¯·å…ˆè¿æ¥WebDAVæœåŠ¡å™¨');
                    return;
                }

                this.setLoading('quickSync', true);
                const result = await this.syncManager.sync('auto');
                this.setLoading('quickSync', false);

                if (result.success) {
                    this.updateSyncStatus('connected', 'åŒæ­¥å®Œæˆ');
                    this.renderCalendar();
                    this.renderData();
                } else {
                    this.updateSyncStatus('error', 'åŒæ­¥å¤±è´¥');
                    alert(`åŒæ­¥å¤±è´¥: ${result.message}`);
                }
            }

            setConnectionStatus(status, text) {
                const dot = document.getElementById('statusDot');
                const statusText = document.getElementById('statusText');
                const connStatus = document.getElementById('connectionStatus');
                const connStatusText = document.getElementById('connectionStatusText');

                dot.className = 'status-dot';
                if (status === 'connected') {
                    dot.classList.add('connected');
                    connStatus.className = 'connection-status connected';
                } else if (status === 'error') {
                    dot.classList.add('error');
                    connStatus.className = 'connection-status error';
                } else {
                    connStatus.className = 'connection-status disconnected';
                }

                statusText.textContent = text;
                connStatusText.textContent = text;
            }

            updateSyncStatus(status, text) {
                const dot = document.getElementById('statusDot');
                const statusText = document.getElementById('statusText');

                dot.className = 'status-dot';
                if (status === 'connected') {
                    dot.classList.add('connected');
                } else if (status === 'error') {
                    dot.classList.add('error');
                }

                statusText.textContent = text;
            }

            setLoading(buttonId, loading) {
                const button = document.getElementById(buttonId);
                if (loading) {
                    button.classList.add('loading');
                    button.disabled = true;
                    if (buttonId === 'quickSync') {
                        button.innerHTML = '<span class="spinner"></span> åŒæ­¥ä¸­...';
                    }
                } else {
                    button.classList.remove('loading');
                    button.disabled = false;
                    if (buttonId === 'quickSync') {
                        button.innerHTML = 'ğŸ”„ åŒæ­¥';
                    }
                }
            }
        }

        // å¯åŠ¨åº”ç”¨
        let app;
        document.addEventListener('DOMContentLoaded', () => {
            app = new ClockApp();
            window.app = app;
        });
    </script>
</body>
</html>
